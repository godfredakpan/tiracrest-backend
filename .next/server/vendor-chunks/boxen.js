"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/boxen";
exports.ids = ["vendor-chunks/boxen"];
exports.modules = {

/***/ "(ssr)/./node_modules/boxen/index.js":
/*!*************************************!*\
  !*** ./node_modules/boxen/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst stringWidth = __webpack_require__(/*! string-width */ \"(ssr)/./node_modules/string-width/index.js\");\nconst chalk = __webpack_require__(/*! chalk */ \"(ssr)/./node_modules/chalk/source/index.js\");\nconst widestLine = __webpack_require__(/*! widest-line */ \"(ssr)/./node_modules/widest-line/index.js\");\nconst cliBoxes = __webpack_require__(/*! cli-boxes */ \"(ssr)/./node_modules/cli-boxes/index.js\");\nconst camelCase = __webpack_require__(/*! camelcase */ \"(ssr)/./node_modules/camelcase/index.js\");\nconst ansiAlign = __webpack_require__(/*! ansi-align */ \"(ssr)/./node_modules/ansi-align/index.js\");\nconst wrapAnsi = __webpack_require__(/*! wrap-ansi */ \"(ssr)/./node_modules/wrap-ansi/index.js\");\n\nconst NL = '\\n';\nconst PAD = ' ';\n\nconst terminalColumns = () => {\n\tconst {env, stdout, stderr} = process;\n\n\tif (stdout && stdout.columns) {\n\t\treturn stdout.columns;\n\t}\n\n\tif (stderr && stderr.columns) {\n\t\treturn stderr.columns;\n\t}\n\n\tif (env.COLUMNS) {\n\t\treturn Number.parseInt(env.COLUMNS, 10);\n\t}\n\n\treturn 80;\n};\n\nconst getObject = detail => {\n\treturn typeof detail === 'number' ? {\n\t\ttop: detail,\n\t\tright: detail * 3,\n\t\tbottom: detail,\n\t\tleft: detail * 3\n\t} : {\n\t\ttop: 0,\n\t\tright: 0,\n\t\tbottom: 0,\n\t\tleft: 0,\n\t\t...detail\n\t};\n};\n\nconst getBorderChars = borderStyle => {\n\tconst sides = [\n\t\t'topLeft',\n\t\t'topRight',\n\t\t'bottomRight',\n\t\t'bottomLeft',\n\t\t'vertical',\n\t\t'horizontal'\n\t];\n\n\tlet chararacters;\n\n\tif (typeof borderStyle === 'string') {\n\t\tchararacters = cliBoxes[borderStyle];\n\n\t\tif (!chararacters) {\n\t\t\tthrow new TypeError(`Invalid border style: ${borderStyle}`);\n\t\t}\n\t} else {\n\t\tfor (const side of sides) {\n\t\t\tif (!borderStyle[side] || typeof borderStyle[side] !== 'string') {\n\t\t\t\tthrow new TypeError(`Invalid border style: ${side}`);\n\t\t\t}\n\t\t}\n\n\t\tchararacters = borderStyle;\n\t}\n\n\treturn chararacters;\n};\n\nconst makeTitle = (text, horizontal, alignement) => {\n\tlet title = '';\n\n\tconst textWidth = stringWidth(text);\n\n\tswitch (alignement) {\n\t\tcase 'left':\n\t\t\ttitle = text + horizontal.slice(textWidth);\n\t\t\tbreak;\n\t\tcase 'right':\n\t\t\ttitle = horizontal.slice(textWidth) + text;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thorizontal = horizontal.slice(textWidth);\n\n\t\t\tif (horizontal.length % 2 === 1) { // This is needed in case the length is odd\n\t\t\t\thorizontal = horizontal.slice(Math.floor(horizontal.length / 2));\n\t\t\t\ttitle = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit\n\t\t\t} else {\n\t\t\t\thorizontal = horizontal.slice(horizontal.length / 2);\n\t\t\t\ttitle = horizontal + text + horizontal;\n\t\t\t}\n\n\t\t\tbreak;\n\t}\n\n\treturn title;\n};\n\nconst makeContentText = (text, padding, columns, align) => {\n\ttext = ansiAlign(text, {align});\n\tlet lines = text.split(NL);\n\tconst textWidth = widestLine(text);\n\n\tconst max = columns - padding.left - padding.right;\n\n\tif (textWidth > max) {\n\t\tconst newLines = [];\n\t\tfor (const line of lines) {\n\t\t\tconst createdLines = wrapAnsi(line, max, {hard: true});\n\t\t\tconst alignedLines = ansiAlign(createdLines, {align});\n\t\t\tconst alignedLinesArray = alignedLines.split('\\n');\n\t\t\tconst longestLength = Math.max(...alignedLinesArray.map(s => stringWidth(s)));\n\n\t\t\tfor (const alignedLine of alignedLinesArray) {\n\t\t\t\tlet paddedLine;\n\t\t\t\tswitch (align) {\n\t\t\t\t\tcase 'center':\n\t\t\t\t\t\tpaddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'right':\n\t\t\t\t\t\tpaddedLine = PAD.repeat(max - longestLength) + alignedLine;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpaddedLine = alignedLine;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tnewLines.push(paddedLine);\n\t\t\t}\n\t\t}\n\n\t\tlines = newLines;\n\t}\n\n\tif (align === 'center' && textWidth < max) {\n\t\tlines = lines.map(line => PAD.repeat((max - textWidth) / 2) + line);\n\t} else if (align === 'right' && textWidth < max) {\n\t\tlines = lines.map(line => PAD.repeat(max - textWidth) + line);\n\t}\n\n\tconst paddingLeft = PAD.repeat(padding.left);\n\tconst paddingRight = PAD.repeat(padding.right);\n\n\tlines = lines.map(line => paddingLeft + line + paddingRight);\n\n\tlines = lines.map(line => {\n\t\tif (columns - stringWidth(line) > 0) {\n\t\t\tswitch (align) {\n\t\t\t\tcase 'center':\n\t\t\t\t\treturn line + PAD.repeat(columns - stringWidth(line));\n\t\t\t\tcase 'right':\n\t\t\t\t\treturn line + PAD.repeat(columns - stringWidth(line));\n\t\t\t\tdefault:\n\t\t\t\t\treturn line + PAD.repeat(columns - stringWidth(line));\n\t\t\t}\n\t\t}\n\n\t\treturn line;\n\t});\n\n\tif (padding.top > 0) {\n\t\tlines = new Array(padding.top).fill(PAD.repeat(columns)).concat(lines);\n\t}\n\n\tif (padding.bottom > 0) {\n\t\tlines = lines.concat(new Array(padding.bottom).fill(PAD.repeat(columns)));\n\t}\n\n\treturn lines.join(NL);\n};\n\nconst isHex = color => color.match(/^#(?:[0-f]{3}){1,2}$/i);\nconst isColorValid = color => typeof color === 'string' && ((chalk[color]) || isHex(color));\nconst getColorFn = color => isHex(color) ? chalk.hex(color) : chalk[color];\nconst getBGColorFn = color => isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];\n\nmodule.exports = (text, options) => {\n\toptions = {\n\t\tpadding: 0,\n\t\tborderStyle: 'single',\n\t\tdimBorder: false,\n\t\ttextAlignment: 'left',\n\t\tfloat: 'left',\n\t\ttitleAlignment: 'left',\n\t\t...options\n\t};\n\n\t// This option is deprecated\n\tif (options.align) {\n\t\toptions.textAlignment = options.align;\n\t}\n\n\tconst BORDERS_WIDTH = 2;\n\n\tif (options.borderColor && !isColorValid(options.borderColor)) {\n\t\tthrow new Error(`${options.borderColor} is not a valid borderColor`);\n\t}\n\n\tif (options.backgroundColor && !isColorValid(options.backgroundColor)) {\n\t\tthrow new Error(`${options.backgroundColor} is not a valid backgroundColor`);\n\t}\n\n\tconst chars = getBorderChars(options.borderStyle);\n\tconst padding = getObject(options.padding);\n\tconst margin = getObject(options.margin);\n\n\tconst colorizeBorder = border => {\n\t\tconst newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;\n\t\treturn options.dimBorder ? chalk.dim(newBorder) : newBorder;\n\t};\n\n\tconst colorizeContent = content => options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;\n\n\tconst columns = terminalColumns();\n\n\tlet contentWidth = widestLine(wrapAnsi(text, columns - BORDERS_WIDTH, {hard: true, trim: false})) + padding.left + padding.right;\n\n\t// This prevents the title bar to exceed the console's width\n\tlet title = options.title && options.title.slice(0, columns - 4 - margin.left - margin.right);\n\n\tif (title) {\n\t\ttitle = ` ${title} `;\n\t\t// Make the box larger to fit a larger title\n\t\tif (stringWidth(title) > contentWidth) {\n\t\t\tcontentWidth = stringWidth(title);\n\t\t}\n\t}\n\n\tif ((margin.left && margin.right) && contentWidth + BORDERS_WIDTH + margin.left + margin.right > columns) {\n\t\t// Let's assume we have margins: left = 3, right = 5, in total = 8\n\t\tconst spaceForMargins = columns - contentWidth - BORDERS_WIDTH;\n\t\t// Let's assume we have space = 4\n\t\tconst multiplier = spaceForMargins / (margin.left + margin.right);\n\t\t// Here: multiplier = 4/8 = 0.5\n\t\tmargin.left = Math.max(0, Math.floor(margin.left * multiplier));\n\t\tmargin.right = Math.max(0, Math.floor(margin.right * multiplier));\n\t\t// Left: 3 * 0.5 = 1.5 -> 1\n\t\t// Right: 6 * 0.5 = 3\n\t}\n\n\t// Prevent content from exceeding the console's width\n\tcontentWidth = Math.min(contentWidth, columns - BORDERS_WIDTH - margin.left - margin.right);\n\n\ttext = makeContentText(text, padding, contentWidth, options.textAlignment);\n\n\tlet marginLeft = PAD.repeat(margin.left);\n\n\tif (options.float === 'center') {\n\t\tconst marginWidth = Math.max((columns - contentWidth - BORDERS_WIDTH) / 2, 0);\n\t\tmarginLeft = PAD.repeat(marginWidth);\n\t} else if (options.float === 'right') {\n\t\tconst marginWidth = Math.max(columns - contentWidth - margin.right - BORDERS_WIDTH, 0);\n\t\tmarginLeft = PAD.repeat(marginWidth);\n\t}\n\n\tconst horizontal = chars.horizontal.repeat(contentWidth);\n\tconst top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + (title ? makeTitle(title, horizontal, options.titleAlignment) : horizontal) + chars.topRight);\n\tconst bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));\n\tconst side = colorizeBorder(chars.vertical);\n\n\tconst LINE_SEPARATOR = (contentWidth + BORDERS_WIDTH + margin.left >= columns) ? '' : NL;\n\n\tconst lines = text.split(NL);\n\n\tconst middle = lines.map(line => {\n\t\treturn marginLeft + side + colorizeContent(line) + side;\n\t}).join(LINE_SEPARATOR);\n\n\treturn top + LINE_SEPARATOR + middle + LINE_SEPARATOR + bottom;\n};\n\nmodule.exports._borderStyles = cliBoxes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm94ZW4vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxjQUFjLG1CQUFPLENBQUMseURBQU87QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMsOERBQWE7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsMERBQVc7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMsMERBQVc7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsNERBQVk7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsMERBQVc7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHFCQUFxQjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0EscURBQXFEO0FBQ3JELEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RCxpREFBaUQsTUFBTTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsRUFBRSxFQUFFLElBQUk7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQzs7QUFFQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHdFQUF3RSx3QkFBd0I7O0FBRWhHO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL29rYm9va3Nob3BuZy8uL25vZGVfbW9kdWxlcy9ib3hlbi9pbmRleC5qcz9mYmQzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHN0cmluZ1dpZHRoID0gcmVxdWlyZSgnc3RyaW5nLXdpZHRoJyk7XG5jb25zdCBjaGFsayA9IHJlcXVpcmUoJ2NoYWxrJyk7XG5jb25zdCB3aWRlc3RMaW5lID0gcmVxdWlyZSgnd2lkZXN0LWxpbmUnKTtcbmNvbnN0IGNsaUJveGVzID0gcmVxdWlyZSgnY2xpLWJveGVzJyk7XG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKCdjYW1lbGNhc2UnKTtcbmNvbnN0IGFuc2lBbGlnbiA9IHJlcXVpcmUoJ2Fuc2ktYWxpZ24nKTtcbmNvbnN0IHdyYXBBbnNpID0gcmVxdWlyZSgnd3JhcC1hbnNpJyk7XG5cbmNvbnN0IE5MID0gJ1xcbic7XG5jb25zdCBQQUQgPSAnICc7XG5cbmNvbnN0IHRlcm1pbmFsQ29sdW1ucyA9ICgpID0+IHtcblx0Y29uc3Qge2Vudiwgc3Rkb3V0LCBzdGRlcnJ9ID0gcHJvY2VzcztcblxuXHRpZiAoc3Rkb3V0ICYmIHN0ZG91dC5jb2x1bW5zKSB7XG5cdFx0cmV0dXJuIHN0ZG91dC5jb2x1bW5zO1xuXHR9XG5cblx0aWYgKHN0ZGVyciAmJiBzdGRlcnIuY29sdW1ucykge1xuXHRcdHJldHVybiBzdGRlcnIuY29sdW1ucztcblx0fVxuXG5cdGlmIChlbnYuQ09MVU1OUykge1xuXHRcdHJldHVybiBOdW1iZXIucGFyc2VJbnQoZW52LkNPTFVNTlMsIDEwKTtcblx0fVxuXG5cdHJldHVybiA4MDtcbn07XG5cbmNvbnN0IGdldE9iamVjdCA9IGRldGFpbCA9PiB7XG5cdHJldHVybiB0eXBlb2YgZGV0YWlsID09PSAnbnVtYmVyJyA/IHtcblx0XHR0b3A6IGRldGFpbCxcblx0XHRyaWdodDogZGV0YWlsICogMyxcblx0XHRib3R0b206IGRldGFpbCxcblx0XHRsZWZ0OiBkZXRhaWwgKiAzXG5cdH0gOiB7XG5cdFx0dG9wOiAwLFxuXHRcdHJpZ2h0OiAwLFxuXHRcdGJvdHRvbTogMCxcblx0XHRsZWZ0OiAwLFxuXHRcdC4uLmRldGFpbFxuXHR9O1xufTtcblxuY29uc3QgZ2V0Qm9yZGVyQ2hhcnMgPSBib3JkZXJTdHlsZSA9PiB7XG5cdGNvbnN0IHNpZGVzID0gW1xuXHRcdCd0b3BMZWZ0Jyxcblx0XHQndG9wUmlnaHQnLFxuXHRcdCdib3R0b21SaWdodCcsXG5cdFx0J2JvdHRvbUxlZnQnLFxuXHRcdCd2ZXJ0aWNhbCcsXG5cdFx0J2hvcml6b250YWwnXG5cdF07XG5cblx0bGV0IGNoYXJhcmFjdGVycztcblxuXHRpZiAodHlwZW9mIGJvcmRlclN0eWxlID09PSAnc3RyaW5nJykge1xuXHRcdGNoYXJhcmFjdGVycyA9IGNsaUJveGVzW2JvcmRlclN0eWxlXTtcblxuXHRcdGlmICghY2hhcmFyYWN0ZXJzKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGJvcmRlciBzdHlsZTogJHtib3JkZXJTdHlsZX1gKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Zm9yIChjb25zdCBzaWRlIG9mIHNpZGVzKSB7XG5cdFx0XHRpZiAoIWJvcmRlclN0eWxlW3NpZGVdIHx8IHR5cGVvZiBib3JkZXJTdHlsZVtzaWRlXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBib3JkZXIgc3R5bGU6ICR7c2lkZX1gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjaGFyYXJhY3RlcnMgPSBib3JkZXJTdHlsZTtcblx0fVxuXG5cdHJldHVybiBjaGFyYXJhY3RlcnM7XG59O1xuXG5jb25zdCBtYWtlVGl0bGUgPSAodGV4dCwgaG9yaXpvbnRhbCwgYWxpZ25lbWVudCkgPT4ge1xuXHRsZXQgdGl0bGUgPSAnJztcblxuXHRjb25zdCB0ZXh0V2lkdGggPSBzdHJpbmdXaWR0aCh0ZXh0KTtcblxuXHRzd2l0Y2ggKGFsaWduZW1lbnQpIHtcblx0XHRjYXNlICdsZWZ0Jzpcblx0XHRcdHRpdGxlID0gdGV4dCArIGhvcml6b250YWwuc2xpY2UodGV4dFdpZHRoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JpZ2h0Jzpcblx0XHRcdHRpdGxlID0gaG9yaXpvbnRhbC5zbGljZSh0ZXh0V2lkdGgpICsgdGV4dDtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRob3Jpem9udGFsID0gaG9yaXpvbnRhbC5zbGljZSh0ZXh0V2lkdGgpO1xuXG5cdFx0XHRpZiAoaG9yaXpvbnRhbC5sZW5ndGggJSAyID09PSAxKSB7IC8vIFRoaXMgaXMgbmVlZGVkIGluIGNhc2UgdGhlIGxlbmd0aCBpcyBvZGRcblx0XHRcdFx0aG9yaXpvbnRhbCA9IGhvcml6b250YWwuc2xpY2UoTWF0aC5mbG9vcihob3Jpem9udGFsLmxlbmd0aCAvIDIpKTtcblx0XHRcdFx0dGl0bGUgPSBob3Jpem9udGFsLnNsaWNlKDEpICsgdGV4dCArIGhvcml6b250YWw7IC8vIFdlIHJlZHVjZSB0aGUgbGVmdCBwYXJ0IG9mIG9uZSBjaGFyYWN0ZXIgdG8gYXZvaWQgdGhlIGJhciB0byBnbyBiZXlvbmQgaXRzIGxpbWl0XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRob3Jpem9udGFsID0gaG9yaXpvbnRhbC5zbGljZShob3Jpem9udGFsLmxlbmd0aCAvIDIpO1xuXHRcdFx0XHR0aXRsZSA9IGhvcml6b250YWwgKyB0ZXh0ICsgaG9yaXpvbnRhbDtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gdGl0bGU7XG59O1xuXG5jb25zdCBtYWtlQ29udGVudFRleHQgPSAodGV4dCwgcGFkZGluZywgY29sdW1ucywgYWxpZ24pID0+IHtcblx0dGV4dCA9IGFuc2lBbGlnbih0ZXh0LCB7YWxpZ259KTtcblx0bGV0IGxpbmVzID0gdGV4dC5zcGxpdChOTCk7XG5cdGNvbnN0IHRleHRXaWR0aCA9IHdpZGVzdExpbmUodGV4dCk7XG5cblx0Y29uc3QgbWF4ID0gY29sdW1ucyAtIHBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQ7XG5cblx0aWYgKHRleHRXaWR0aCA+IG1heCkge1xuXHRcdGNvbnN0IG5ld0xpbmVzID0gW107XG5cdFx0Zm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG5cdFx0XHRjb25zdCBjcmVhdGVkTGluZXMgPSB3cmFwQW5zaShsaW5lLCBtYXgsIHtoYXJkOiB0cnVlfSk7XG5cdFx0XHRjb25zdCBhbGlnbmVkTGluZXMgPSBhbnNpQWxpZ24oY3JlYXRlZExpbmVzLCB7YWxpZ259KTtcblx0XHRcdGNvbnN0IGFsaWduZWRMaW5lc0FycmF5ID0gYWxpZ25lZExpbmVzLnNwbGl0KCdcXG4nKTtcblx0XHRcdGNvbnN0IGxvbmdlc3RMZW5ndGggPSBNYXRoLm1heCguLi5hbGlnbmVkTGluZXNBcnJheS5tYXAocyA9PiBzdHJpbmdXaWR0aChzKSkpO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGFsaWduZWRMaW5lIG9mIGFsaWduZWRMaW5lc0FycmF5KSB7XG5cdFx0XHRcdGxldCBwYWRkZWRMaW5lO1xuXHRcdFx0XHRzd2l0Y2ggKGFsaWduKSB7XG5cdFx0XHRcdFx0Y2FzZSAnY2VudGVyJzpcblx0XHRcdFx0XHRcdHBhZGRlZExpbmUgPSBQQUQucmVwZWF0KChtYXggLSBsb25nZXN0TGVuZ3RoKSAvIDIpICsgYWxpZ25lZExpbmU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdyaWdodCc6XG5cdFx0XHRcdFx0XHRwYWRkZWRMaW5lID0gUEFELnJlcGVhdChtYXggLSBsb25nZXN0TGVuZ3RoKSArIGFsaWduZWRMaW5lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHBhZGRlZExpbmUgPSBhbGlnbmVkTGluZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3TGluZXMucHVzaChwYWRkZWRMaW5lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsaW5lcyA9IG5ld0xpbmVzO1xuXHR9XG5cblx0aWYgKGFsaWduID09PSAnY2VudGVyJyAmJiB0ZXh0V2lkdGggPCBtYXgpIHtcblx0XHRsaW5lcyA9IGxpbmVzLm1hcChsaW5lID0+IFBBRC5yZXBlYXQoKG1heCAtIHRleHRXaWR0aCkgLyAyKSArIGxpbmUpO1xuXHR9IGVsc2UgaWYgKGFsaWduID09PSAncmlnaHQnICYmIHRleHRXaWR0aCA8IG1heCkge1xuXHRcdGxpbmVzID0gbGluZXMubWFwKGxpbmUgPT4gUEFELnJlcGVhdChtYXggLSB0ZXh0V2lkdGgpICsgbGluZSk7XG5cdH1cblxuXHRjb25zdCBwYWRkaW5nTGVmdCA9IFBBRC5yZXBlYXQocGFkZGluZy5sZWZ0KTtcblx0Y29uc3QgcGFkZGluZ1JpZ2h0ID0gUEFELnJlcGVhdChwYWRkaW5nLnJpZ2h0KTtcblxuXHRsaW5lcyA9IGxpbmVzLm1hcChsaW5lID0+IHBhZGRpbmdMZWZ0ICsgbGluZSArIHBhZGRpbmdSaWdodCk7XG5cblx0bGluZXMgPSBsaW5lcy5tYXAobGluZSA9PiB7XG5cdFx0aWYgKGNvbHVtbnMgLSBzdHJpbmdXaWR0aChsaW5lKSA+IDApIHtcblx0XHRcdHN3aXRjaCAoYWxpZ24pIHtcblx0XHRcdFx0Y2FzZSAnY2VudGVyJzpcblx0XHRcdFx0XHRyZXR1cm4gbGluZSArIFBBRC5yZXBlYXQoY29sdW1ucyAtIHN0cmluZ1dpZHRoKGxpbmUpKTtcblx0XHRcdFx0Y2FzZSAncmlnaHQnOlxuXHRcdFx0XHRcdHJldHVybiBsaW5lICsgUEFELnJlcGVhdChjb2x1bW5zIC0gc3RyaW5nV2lkdGgobGluZSkpO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBsaW5lICsgUEFELnJlcGVhdChjb2x1bW5zIC0gc3RyaW5nV2lkdGgobGluZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lO1xuXHR9KTtcblxuXHRpZiAocGFkZGluZy50b3AgPiAwKSB7XG5cdFx0bGluZXMgPSBuZXcgQXJyYXkocGFkZGluZy50b3ApLmZpbGwoUEFELnJlcGVhdChjb2x1bW5zKSkuY29uY2F0KGxpbmVzKTtcblx0fVxuXG5cdGlmIChwYWRkaW5nLmJvdHRvbSA+IDApIHtcblx0XHRsaW5lcyA9IGxpbmVzLmNvbmNhdChuZXcgQXJyYXkocGFkZGluZy5ib3R0b20pLmZpbGwoUEFELnJlcGVhdChjb2x1bW5zKSkpO1xuXHR9XG5cblx0cmV0dXJuIGxpbmVzLmpvaW4oTkwpO1xufTtcblxuY29uc3QgaXNIZXggPSBjb2xvciA9PiBjb2xvci5tYXRjaCgvXiMoPzpbMC1mXXszfSl7MSwyfSQvaSk7XG5jb25zdCBpc0NvbG9yVmFsaWQgPSBjb2xvciA9PiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmICgoY2hhbGtbY29sb3JdKSB8fCBpc0hleChjb2xvcikpO1xuY29uc3QgZ2V0Q29sb3JGbiA9IGNvbG9yID0+IGlzSGV4KGNvbG9yKSA/IGNoYWxrLmhleChjb2xvcikgOiBjaGFsa1tjb2xvcl07XG5jb25zdCBnZXRCR0NvbG9yRm4gPSBjb2xvciA9PiBpc0hleChjb2xvcikgPyBjaGFsay5iZ0hleChjb2xvcikgOiBjaGFsa1tjYW1lbENhc2UoWydiZycsIGNvbG9yXSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh0ZXh0LCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0cGFkZGluZzogMCxcblx0XHRib3JkZXJTdHlsZTogJ3NpbmdsZScsXG5cdFx0ZGltQm9yZGVyOiBmYWxzZSxcblx0XHR0ZXh0QWxpZ25tZW50OiAnbGVmdCcsXG5cdFx0ZmxvYXQ6ICdsZWZ0Jyxcblx0XHR0aXRsZUFsaWdubWVudDogJ2xlZnQnLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHQvLyBUaGlzIG9wdGlvbiBpcyBkZXByZWNhdGVkXG5cdGlmIChvcHRpb25zLmFsaWduKSB7XG5cdFx0b3B0aW9ucy50ZXh0QWxpZ25tZW50ID0gb3B0aW9ucy5hbGlnbjtcblx0fVxuXG5cdGNvbnN0IEJPUkRFUlNfV0lEVEggPSAyO1xuXG5cdGlmIChvcHRpb25zLmJvcmRlckNvbG9yICYmICFpc0NvbG9yVmFsaWQob3B0aW9ucy5ib3JkZXJDb2xvcikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy5ib3JkZXJDb2xvcn0gaXMgbm90IGEgdmFsaWQgYm9yZGVyQ29sb3JgKTtcblx0fVxuXG5cdGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvciAmJiAhaXNDb2xvclZhbGlkKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLmJhY2tncm91bmRDb2xvcn0gaXMgbm90IGEgdmFsaWQgYmFja2dyb3VuZENvbG9yYCk7XG5cdH1cblxuXHRjb25zdCBjaGFycyA9IGdldEJvcmRlckNoYXJzKG9wdGlvbnMuYm9yZGVyU3R5bGUpO1xuXHRjb25zdCBwYWRkaW5nID0gZ2V0T2JqZWN0KG9wdGlvbnMucGFkZGluZyk7XG5cdGNvbnN0IG1hcmdpbiA9IGdldE9iamVjdChvcHRpb25zLm1hcmdpbik7XG5cblx0Y29uc3QgY29sb3JpemVCb3JkZXIgPSBib3JkZXIgPT4ge1xuXHRcdGNvbnN0IG5ld0JvcmRlciA9IG9wdGlvbnMuYm9yZGVyQ29sb3IgPyBnZXRDb2xvckZuKG9wdGlvbnMuYm9yZGVyQ29sb3IpKGJvcmRlcikgOiBib3JkZXI7XG5cdFx0cmV0dXJuIG9wdGlvbnMuZGltQm9yZGVyID8gY2hhbGsuZGltKG5ld0JvcmRlcikgOiBuZXdCb3JkZXI7XG5cdH07XG5cblx0Y29uc3QgY29sb3JpemVDb250ZW50ID0gY29udGVudCA9PiBvcHRpb25zLmJhY2tncm91bmRDb2xvciA/IGdldEJHQ29sb3JGbihvcHRpb25zLmJhY2tncm91bmRDb2xvcikoY29udGVudCkgOiBjb250ZW50O1xuXG5cdGNvbnN0IGNvbHVtbnMgPSB0ZXJtaW5hbENvbHVtbnMoKTtcblxuXHRsZXQgY29udGVudFdpZHRoID0gd2lkZXN0TGluZSh3cmFwQW5zaSh0ZXh0LCBjb2x1bW5zIC0gQk9SREVSU19XSURUSCwge2hhcmQ6IHRydWUsIHRyaW06IGZhbHNlfSkpICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcblxuXHQvLyBUaGlzIHByZXZlbnRzIHRoZSB0aXRsZSBiYXIgdG8gZXhjZWVkIHRoZSBjb25zb2xlJ3Mgd2lkdGhcblx0bGV0IHRpdGxlID0gb3B0aW9ucy50aXRsZSAmJiBvcHRpb25zLnRpdGxlLnNsaWNlKDAsIGNvbHVtbnMgLSA0IC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xuXG5cdGlmICh0aXRsZSkge1xuXHRcdHRpdGxlID0gYCAke3RpdGxlfSBgO1xuXHRcdC8vIE1ha2UgdGhlIGJveCBsYXJnZXIgdG8gZml0IGEgbGFyZ2VyIHRpdGxlXG5cdFx0aWYgKHN0cmluZ1dpZHRoKHRpdGxlKSA+IGNvbnRlbnRXaWR0aCkge1xuXHRcdFx0Y29udGVudFdpZHRoID0gc3RyaW5nV2lkdGgodGl0bGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICgobWFyZ2luLmxlZnQgJiYgbWFyZ2luLnJpZ2h0KSAmJiBjb250ZW50V2lkdGggKyBCT1JERVJTX1dJRFRIICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQgPiBjb2x1bW5zKSB7XG5cdFx0Ly8gTGV0J3MgYXNzdW1lIHdlIGhhdmUgbWFyZ2luczogbGVmdCA9IDMsIHJpZ2h0ID0gNSwgaW4gdG90YWwgPSA4XG5cdFx0Y29uc3Qgc3BhY2VGb3JNYXJnaW5zID0gY29sdW1ucyAtIGNvbnRlbnRXaWR0aCAtIEJPUkRFUlNfV0lEVEg7XG5cdFx0Ly8gTGV0J3MgYXNzdW1lIHdlIGhhdmUgc3BhY2UgPSA0XG5cdFx0Y29uc3QgbXVsdGlwbGllciA9IHNwYWNlRm9yTWFyZ2lucyAvIChtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCk7XG5cdFx0Ly8gSGVyZTogbXVsdGlwbGllciA9IDQvOCA9IDAuNVxuXHRcdG1hcmdpbi5sZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihtYXJnaW4ubGVmdCAqIG11bHRpcGxpZXIpKTtcblx0XHRtYXJnaW4ucmlnaHQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKG1hcmdpbi5yaWdodCAqIG11bHRpcGxpZXIpKTtcblx0XHQvLyBMZWZ0OiAzICogMC41ID0gMS41IC0+IDFcblx0XHQvLyBSaWdodDogNiAqIDAuNSA9IDNcblx0fVxuXG5cdC8vIFByZXZlbnQgY29udGVudCBmcm9tIGV4Y2VlZGluZyB0aGUgY29uc29sZSdzIHdpZHRoXG5cdGNvbnRlbnRXaWR0aCA9IE1hdGgubWluKGNvbnRlbnRXaWR0aCwgY29sdW1ucyAtIEJPUkRFUlNfV0lEVEggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCk7XG5cblx0dGV4dCA9IG1ha2VDb250ZW50VGV4dCh0ZXh0LCBwYWRkaW5nLCBjb250ZW50V2lkdGgsIG9wdGlvbnMudGV4dEFsaWdubWVudCk7XG5cblx0bGV0IG1hcmdpbkxlZnQgPSBQQUQucmVwZWF0KG1hcmdpbi5sZWZ0KTtcblxuXHRpZiAob3B0aW9ucy5mbG9hdCA9PT0gJ2NlbnRlcicpIHtcblx0XHRjb25zdCBtYXJnaW5XaWR0aCA9IE1hdGgubWF4KChjb2x1bW5zIC0gY29udGVudFdpZHRoIC0gQk9SREVSU19XSURUSCkgLyAyLCAwKTtcblx0XHRtYXJnaW5MZWZ0ID0gUEFELnJlcGVhdChtYXJnaW5XaWR0aCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5mbG9hdCA9PT0gJ3JpZ2h0Jykge1xuXHRcdGNvbnN0IG1hcmdpbldpZHRoID0gTWF0aC5tYXgoY29sdW1ucyAtIGNvbnRlbnRXaWR0aCAtIG1hcmdpbi5yaWdodCAtIEJPUkRFUlNfV0lEVEgsIDApO1xuXHRcdG1hcmdpbkxlZnQgPSBQQUQucmVwZWF0KG1hcmdpbldpZHRoKTtcblx0fVxuXG5cdGNvbnN0IGhvcml6b250YWwgPSBjaGFycy5ob3Jpem9udGFsLnJlcGVhdChjb250ZW50V2lkdGgpO1xuXHRjb25zdCB0b3AgPSBjb2xvcml6ZUJvcmRlcihOTC5yZXBlYXQobWFyZ2luLnRvcCkgKyBtYXJnaW5MZWZ0ICsgY2hhcnMudG9wTGVmdCArICh0aXRsZSA/IG1ha2VUaXRsZSh0aXRsZSwgaG9yaXpvbnRhbCwgb3B0aW9ucy50aXRsZUFsaWdubWVudCkgOiBob3Jpem9udGFsKSArIGNoYXJzLnRvcFJpZ2h0KTtcblx0Y29uc3QgYm90dG9tID0gY29sb3JpemVCb3JkZXIobWFyZ2luTGVmdCArIGNoYXJzLmJvdHRvbUxlZnQgKyBob3Jpem9udGFsICsgY2hhcnMuYm90dG9tUmlnaHQgKyBOTC5yZXBlYXQobWFyZ2luLmJvdHRvbSkpO1xuXHRjb25zdCBzaWRlID0gY29sb3JpemVCb3JkZXIoY2hhcnMudmVydGljYWwpO1xuXG5cdGNvbnN0IExJTkVfU0VQQVJBVE9SID0gKGNvbnRlbnRXaWR0aCArIEJPUkRFUlNfV0lEVEggKyBtYXJnaW4ubGVmdCA+PSBjb2x1bW5zKSA/ICcnIDogTkw7XG5cblx0Y29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KE5MKTtcblxuXHRjb25zdCBtaWRkbGUgPSBsaW5lcy5tYXAobGluZSA9PiB7XG5cdFx0cmV0dXJuIG1hcmdpbkxlZnQgKyBzaWRlICsgY29sb3JpemVDb250ZW50KGxpbmUpICsgc2lkZTtcblx0fSkuam9pbihMSU5FX1NFUEFSQVRPUik7XG5cblx0cmV0dXJuIHRvcCArIExJTkVfU0VQQVJBVE9SICsgbWlkZGxlICsgTElORV9TRVBBUkFUT1IgKyBib3R0b207XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5fYm9yZGVyU3R5bGVzID0gY2xpQm94ZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/boxen/index.js\n");

/***/ })

};
;