"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/umi-request";
exports.ids = ["vendor-chunks/umi-request"];
exports.modules = {

/***/ "(ssr)/./node_modules/umi-request/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/umi-request/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar qs = __webpack_require__(/*! qs */ \"(ssr)/./node_modules/qs/lib/index.js\");\n__webpack_require__(/*! isomorphic-fetch */ \"(ssr)/./node_modules/isomorphic-fetch/fetch-npm-node.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n// 返回一个组合了所有插件的“插件”\nfunction compose(middlewares) {\n  if (!Array.isArray(middlewares)) throw new TypeError('Middlewares must be an array!');\n  var middlewaresLen = middlewares.length;\n\n  for (var i = 0; i < middlewaresLen; i++) {\n    if (typeof middlewares[i] !== 'function') {\n      throw new TypeError('Middleware must be componsed of function');\n    }\n  }\n\n  return function wrapMiddlewares(params, next) {\n    var index = -1;\n\n    function dispatch(i) {\n      if (i <= index) {\n        return Promise.reject(new Error('next() should not be called multiple times in one middleware!'));\n      }\n\n      index = i;\n      var fn = middlewares[i] || next;\n      if (!fn) return Promise.resolve();\n\n      try {\n        return Promise.resolve(fn(params, function () {\n          return dispatch(i + 1);\n        }));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n\n    return dispatch(0);\n  };\n}\n\nvar Onion = /*#__PURE__*/function () {\n  function Onion(defaultMiddlewares) {\n    _classCallCheck(this, Onion);\n\n    if (!Array.isArray(defaultMiddlewares)) throw new TypeError('Default middlewares must be an array!');\n    this.defaultMiddlewares = _toConsumableArray(defaultMiddlewares);\n    this.middlewares = [];\n  }\n\n  _createClass(Onion, [{\n    key: \"use\",\n    value: // 内置内核中间件长度\n    function use(newMiddleware) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        global: false,\n        core: false,\n        defaultInstance: false\n      };\n      var core = false;\n      var global = false;\n      var defaultInstance = false;\n\n      if (typeof opts === 'number') {\n        if (process && process.env && \"development\" === 'development') {\n          console.warn('use() options should be object, number property would be deprecated in future，please update use() options to \"{ core: true }\".');\n        }\n\n        core = true;\n        global = false;\n      } else if (_typeof(opts) === 'object' && opts) {\n        global = opts.global || false;\n        core = opts.core || false;\n        defaultInstance = opts.defaultInstance || false;\n      } // 全局中间件\n\n\n      if (global) {\n        Onion.globalMiddlewares.splice(Onion.globalMiddlewares.length - Onion.defaultGlobalMiddlewaresLength, 0, newMiddleware);\n        return;\n      } // 内核中间件\n\n\n      if (core) {\n        Onion.coreMiddlewares.splice(Onion.coreMiddlewares.length - Onion.defaultCoreMiddlewaresLength, 0, newMiddleware);\n        return;\n      } // 默认实例中间件，供开发者使用\n\n\n      if (defaultInstance) {\n        this.defaultMiddlewares.push(newMiddleware);\n        return;\n      } // 实例中间件\n\n\n      this.middlewares.push(newMiddleware);\n    }\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var fn = compose([].concat(_toConsumableArray(this.middlewares), _toConsumableArray(this.defaultMiddlewares), _toConsumableArray(Onion.globalMiddlewares), _toConsumableArray(Onion.coreMiddlewares)));\n      return fn(params);\n    }\n  }]);\n\n  return Onion;\n}();\n\nOnion.globalMiddlewares = [];\nOnion.defaultGlobalMiddlewaresLength = 0;\nOnion.coreMiddlewares = [];\nOnion.defaultCoreMiddlewaresLength = 0;\n\nvar MapCache = /*#__PURE__*/function () {\n  function MapCache(options) {\n    _classCallCheck(this, MapCache);\n\n    this.cache = new Map();\n    this.timer = {};\n    this.extendOptions(options);\n  }\n\n  _createClass(MapCache, [{\n    key: \"extendOptions\",\n    value: function extendOptions(options) {\n      this.maxCache = options.maxCache || 0;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this.cache.get(JSON.stringify(key));\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      var _this = this;\n\n      var ttl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n\n      // 如果超过最大缓存数, 删除头部的第一个缓存.\n      if (this.maxCache > 0 && this.cache.size >= this.maxCache) {\n        var deleteKey = _toConsumableArray(this.cache.keys())[0];\n\n        this.cache.delete(deleteKey);\n\n        if (this.timer[deleteKey]) {\n          clearTimeout(this.timer[deleteKey]);\n        }\n      }\n\n      var cacheKey = JSON.stringify(key);\n      this.cache.set(cacheKey, value);\n\n      if (ttl > 0) {\n        this.timer[cacheKey] = setTimeout(function () {\n          _this.cache.delete(cacheKey);\n\n          delete _this.timer[cacheKey];\n        }, ttl);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var cacheKey = JSON.stringify(key);\n      delete this.timer[cacheKey];\n      return this.cache.delete(cacheKey);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.timer = {};\n      return this.cache.clear();\n    }\n  }]);\n\n  return MapCache;\n}();\n/**\n * 请求异常\n */\n\nvar RequestError = /*#__PURE__*/function (_Error) {\n  _inherits(RequestError, _Error);\n\n  var _super = _createSuper(RequestError);\n\n  function RequestError(text, request) {\n    var _this2;\n\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'RequestError';\n\n    _classCallCheck(this, RequestError);\n\n    _this2 = _super.call(this, text);\n    _this2.name = 'RequestError';\n    _this2.request = request;\n    _this2.type = type;\n    return _this2;\n  }\n\n  return RequestError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * 响应异常\n */\n\nvar ResponseError = /*#__PURE__*/function (_Error2) {\n  _inherits(ResponseError, _Error2);\n\n  var _super2 = _createSuper(ResponseError);\n\n  function ResponseError(response, text, data, request) {\n    var _this3;\n\n    var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ResponseError';\n\n    _classCallCheck(this, ResponseError);\n\n    _this3 = _super2.call(this, text || response.statusText);\n    _this3.name = 'ResponseError';\n    _this3.data = data;\n    _this3.response = response;\n    _this3.request = request;\n    _this3.type = type;\n    return _this3;\n  }\n\n  return ResponseError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * http://gitlab.alipay-inc.com/KBSJ/gxt/blob/release_gxt_S8928905_20180531/src/util/request.js#L63\n * 支持gbk\n */\n\nfunction readerGBK(file) {\n  return new Promise(function (resolve, reject) {\n    var reader = new FileReader();\n\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n\n    reader.onerror = reject;\n    reader.readAsText(file, 'GBK'); // setup GBK decoding\n  });\n}\n/**\n * 安全的JSON.parse\n */\n\nfunction safeJsonParse(data) {\n  var throwErrIfParseFail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var response = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var request = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  try {\n    return JSON.parse(data);\n  } catch (e) {\n    if (throwErrIfParseFail) {\n      throw new ResponseError(response, 'JSON.parse fail', data, request, 'ParseError');\n    }\n  } // eslint-disable-line no-empty\n\n\n  return data;\n}\nfunction timeout2Throw(msec, timeoutMessage, request) {\n  return new Promise(function (_, reject) {\n    setTimeout(function () {\n      reject(new RequestError(timeoutMessage || \"timeout of \".concat(msec, \"ms exceeded\"), request, 'Timeout'));\n    }, msec);\n  });\n} // If request options contain 'cancelToken', reject request when token has been canceled\n\nfunction cancel2Throw(opt) {\n  return new Promise(function (_, reject) {\n    if (opt.cancelToken) {\n      opt.cancelToken.promise.then(function (cancel) {\n        reject(cancel);\n      });\n    }\n  });\n}\nvar toString = Object.prototype.toString; // Check env is browser or node\n\nfunction getEnv() {\n  var env; // Only Node.JS has a process variable that is of [[Class]] process\n\n  if (typeof process !== 'undefined' && toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    env = 'NODE';\n  }\n\n  if (typeof XMLHttpRequest !== 'undefined') {\n    env = 'BROWSER';\n  }\n\n  return env;\n}\nfunction isArray(val) {\n  return _typeof(val) === 'object' && Object.prototype.toString.call(val) === '[object Array]';\n}\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\nfunction isDate(val) {\n  return _typeof(val) === 'object' && Object.prototype.toString.call(val) === '[object Date]';\n}\nfunction isObject(val) {\n  return val !== null && _typeof(val) === 'object';\n}\nfunction forEach2ObjArr(target, callback) {\n  if (!target) return;\n\n  if (_typeof(target) !== 'object') {\n    target = [target];\n  }\n\n  if (isArray(target)) {\n    for (var i = 0; i < target.length; i++) {\n      callback.call(null, target[i], i, target);\n    }\n  } else {\n    for (var key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        callback.call(null, target[key], key, target);\n      }\n    }\n  }\n}\nfunction getParamObject(val) {\n  if (isURLSearchParams(val)) {\n    return qs.parse(val.toString(), {\n      strictNullHandling: true\n    });\n  }\n\n  if (typeof val === 'string') {\n    return [val];\n  }\n\n  return val;\n}\nfunction reqStringify(val) {\n  return qs.stringify(val, {\n    arrayFormat: 'repeat',\n    strictNullHandling: true\n  });\n}\nfunction mergeRequestOptions(options, options2Merge) {\n  return _objectSpread2(_objectSpread2(_objectSpread2({}, options), options2Merge), {}, {\n    headers: _objectSpread2(_objectSpread2({}, options.headers), options2Merge.headers),\n    params: _objectSpread2(_objectSpread2({}, getParamObject(options.params)), getParamObject(options2Merge.params)),\n    method: (options2Merge.method || options.method || 'get').toLowerCase()\n  });\n}\n\n// 前后缀拦截\nvar addfix = function addfix(url) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var prefix = options.prefix,\n      suffix = options.suffix;\n\n  if (prefix) {\n    url = \"\".concat(prefix).concat(url);\n  }\n\n  if (suffix) {\n    url = \"\".concat(url).concat(suffix);\n  }\n\n  return {\n    url: url,\n    options: options\n  };\n};\n\nvar warnedCoreType = false; // 默认缓存判断，开放缓存判断给非 get 请求使用\n\nfunction __defaultValidateCache(url, options) {\n  var _options$method = options.method,\n      method = _options$method === void 0 ? 'get' : _options$method;\n  return method.toLowerCase() === 'get';\n}\n\nfunction fetchMiddleware(ctx, next) {\n  if (!ctx) return next();\n  var _ctx$req = ctx.req;\n  _ctx$req = _ctx$req === void 0 ? {} : _ctx$req;\n  var _ctx$req$options = _ctx$req.options,\n      options = _ctx$req$options === void 0 ? {} : _ctx$req$options,\n      _ctx$req$url = _ctx$req.url,\n      url = _ctx$req$url === void 0 ? '' : _ctx$req$url,\n      cache = ctx.cache,\n      responseInterceptors = ctx.responseInterceptors;\n\n  var _options$timeout = options.timeout,\n      timeout = _options$timeout === void 0 ? 0 : _options$timeout,\n      timeoutMessage = options.timeoutMessage,\n      _options$__umiRequest = options.__umiRequestCoreType__,\n      __umiRequestCoreType__ = _options$__umiRequest === void 0 ? 'normal' : _options$__umiRequest,\n      _options$useCache = options.useCache,\n      useCache = _options$useCache === void 0 ? false : _options$useCache,\n      _options$method2 = options.method,\n      method = _options$method2 === void 0 ? 'get' : _options$method2,\n      params = options.params,\n      ttl = options.ttl,\n      _options$validateCach = options.validateCache,\n      validateCache = _options$validateCach === void 0 ? __defaultValidateCache : _options$validateCach;\n\n  if (__umiRequestCoreType__ !== 'normal') {\n    if (process && process.env && \"development\" === 'development' && warnedCoreType === false) {\n      warnedCoreType = true;\n      console.warn('__umiRequestCoreType__ is a internal property that use in umi-request, change its value would affect the behavior of request! It only use when you want to extend or use request core.');\n    }\n\n    return next();\n  }\n\n  var adapter = fetch;\n\n  if (!adapter) {\n    throw new Error('Global fetch not exist!');\n  } // 从缓存池检查是否有缓存数据\n\n\n  var isBrowser = getEnv() === 'BROWSER';\n  var needCache = validateCache(url, options) && useCache && isBrowser;\n\n  if (needCache) {\n    var responseCache = cache.get({\n      url: url,\n      params: params,\n      method: method\n    });\n\n    if (responseCache) {\n      responseCache = responseCache.clone();\n      responseCache.useCache = true;\n      ctx.res = responseCache;\n      return next();\n    }\n  }\n\n  var response; // 超时处理、取消请求处理\n\n  if (timeout > 0) {\n    response = Promise.race([cancel2Throw(options), adapter(url, options), timeout2Throw(timeout, timeoutMessage, ctx.req)]);\n  } else {\n    response = Promise.race([cancel2Throw(options), adapter(url, options)]);\n  } // 兼容老版本 response.interceptor\n\n\n  responseInterceptors.forEach(function (handler) {\n    response = response.then(function (res) {\n      // Fix multiple clones not working, issue: https://github.com/github/fetch/issues/504\n      var clonedRes = typeof res.clone === 'function' ? res.clone() : res;\n      return handler(clonedRes, options);\n    });\n  });\n  return response.then(function (res) {\n    // 是否存入缓存池\n    if (needCache) {\n      if (res.status === 200) {\n        var copy = res.clone();\n        copy.useCache = true;\n        cache.set({\n          url: url,\n          params: params,\n          method: method\n        }, copy, ttl);\n      }\n    }\n\n    ctx.res = res;\n    return next();\n  });\n}\n\nfunction parseResponseMiddleware(ctx, next) {\n  var copy;\n  return next().then(function () {\n    if (!ctx) return;\n    var _ctx$res = ctx.res,\n        res = _ctx$res === void 0 ? {} : _ctx$res,\n        _ctx$req = ctx.req,\n        req = _ctx$req === void 0 ? {} : _ctx$req;\n\n    var _ref = req || {},\n        _ref$options = _ref.options;\n\n    _ref$options = _ref$options === void 0 ? {} : _ref$options;\n    var _ref$options$response = _ref$options.responseType,\n        responseType = _ref$options$response === void 0 ? 'json' : _ref$options$response,\n        _ref$options$charset = _ref$options.charset,\n        charset = _ref$options$charset === void 0 ? 'utf8' : _ref$options$charset,\n        _ref$options$getRespo = _ref$options.getResponse,\n        _ref$options$throwErr = _ref$options.throwErrIfParseFail,\n        throwErrIfParseFail = _ref$options$throwErr === void 0 ? false : _ref$options$throwErr,\n        _ref$options$parseRes = _ref$options.parseResponse,\n        parseResponse = _ref$options$parseRes === void 0 ? true : _ref$options$parseRes;\n\n    if (!parseResponse) {\n      return;\n    }\n\n    if (!res || !res.clone) {\n      return;\n    } // 只在浏览器环境对 response 做克隆， node 环境如果对 response 克隆会有问题：https://github.com/bitinn/node-fetch/issues/553\n\n\n    copy = getEnv() === 'BROWSER' ? res.clone() : res;\n    copy.useCache = res.useCache || false; // 解析数据\n\n    if (charset === 'gbk') {\n      try {\n        return res.blob().then(readerGBK).then(function (d) {\n          return safeJsonParse(d, false, copy, req);\n        });\n      } catch (e) {\n        throw new ResponseError(copy, e.message, null, req, 'ParseError');\n      }\n    } else if (responseType === 'json') {\n      return res.text().then(function (d) {\n        return safeJsonParse(d, throwErrIfParseFail, copy, req);\n      });\n    }\n\n    try {\n      // 其他如text, blob, arrayBuffer, formData\n      return res[responseType]();\n    } catch (e) {\n      throw new ResponseError(copy, 'responseType not support', null, req, 'ParseError');\n    }\n  }).then(function (body) {\n    if (!ctx) return;\n    var _ctx$res2 = ctx.res,\n        _ctx$req2 = ctx.req,\n        req = _ctx$req2 === void 0 ? {} : _ctx$req2;\n\n    var _ref2 = req || {},\n        _ref2$options = _ref2.options;\n\n    _ref2$options = _ref2$options === void 0 ? {} : _ref2$options;\n    var _ref2$options$getResp = _ref2$options.getResponse,\n        getResponse = _ref2$options$getResp === void 0 ? false : _ref2$options$getResp;\n\n    if (!copy) {\n      return;\n    }\n\n    if (copy.status >= 200 && copy.status < 300) {\n      // 提供源response, 以便自定义处理\n      if (getResponse) {\n        ctx.res = {\n          data: body,\n          response: copy\n        };\n        return;\n      }\n\n      ctx.res = body;\n      return;\n    }\n\n    throw new ResponseError(copy, 'http error', body, req, 'HttpError');\n  }).catch(function (e) {\n    if (e instanceof RequestError || e instanceof ResponseError) {\n      throw e;\n    } // 对未知错误进行处理\n\n\n    var req = ctx.req,\n        res = ctx.res;\n    e.request = e.request || req;\n    e.response = e.response || res;\n    e.type = e.type || e.name;\n    e.data = e.data || undefined;\n    throw e;\n  });\n}\n\nfunction simplePostMiddleware(ctx, next) {\n  if (!ctx) return next();\n  var _ctx$req = ctx.req;\n  _ctx$req = _ctx$req === void 0 ? {} : _ctx$req;\n  var _ctx$req$options = _ctx$req.options,\n      options = _ctx$req$options === void 0 ? {} : _ctx$req$options;\n  var _options$method = options.method,\n      method = _options$method === void 0 ? 'get' : _options$method;\n\n  if (['post', 'put', 'patch', 'delete'].indexOf(method.toLowerCase()) === -1) {\n    return next();\n  }\n\n  var _options$requestType = options.requestType,\n      requestType = _options$requestType === void 0 ? 'json' : _options$requestType,\n      data = options.data; // 数据使用类axios的新字段data, 避免引用后影响旧代码, 如将body stringify多次\n\n  if (data) {\n    var dataType = Object.prototype.toString.call(data);\n\n    if (dataType === '[object Object]' || dataType === '[object Array]') {\n      if (requestType === 'json') {\n        options.headers = _objectSpread2({\n          Accept: 'application/json',\n          'Content-Type': 'application/json;charset=UTF-8'\n        }, options.headers);\n        options.body = JSON.stringify(data);\n      } else if (requestType === 'form') {\n        options.headers = _objectSpread2({\n          Accept: 'application/json',\n          'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'\n        }, options.headers);\n        options.body = reqStringify(data);\n      }\n    } else {\n      // 其他 requestType 自定义header\n      options.headers = _objectSpread2({\n        Accept: 'application/json'\n      }, options.headers);\n      options.body = data;\n    }\n  }\n\n  ctx.req.options = options;\n  return next();\n}\n\nfunction paramsSerialize(params, paramsSerializer) {\n  var serializedParams;\n  var jsonStringifiedParams; // 支持参数自动拼装，其他 method 也可用，不冲突\n\n  if (params) {\n    if (paramsSerializer) {\n      serializedParams = paramsSerializer(params);\n    } else if (isURLSearchParams(params)) {\n      serializedParams = params.toString();\n    } else {\n      if (isArray(params)) {\n        jsonStringifiedParams = [];\n        forEach2ObjArr(params, function (item) {\n          if (item === null || typeof item === 'undefined') {\n            jsonStringifiedParams.push(item);\n          } else {\n            jsonStringifiedParams.push(isObject(item) ? JSON.stringify(item) : item);\n          }\n        }); // a: [1,2,3] => a=1&a=2&a=3\n\n        serializedParams = reqStringify(jsonStringifiedParams);\n      } else {\n        jsonStringifiedParams = {};\n        forEach2ObjArr(params, function (value, key) {\n          var jsonStringifiedValue = value;\n\n          if (value === null || typeof value === 'undefined') {\n            jsonStringifiedParams[key] = value;\n          } else if (isDate(value)) {\n            jsonStringifiedValue = value.toISOString();\n          } else if (isArray(value)) {\n            jsonStringifiedValue = value;\n          } else if (isObject(value)) {\n            jsonStringifiedValue = JSON.stringify(value);\n          }\n\n          jsonStringifiedParams[key] = jsonStringifiedValue;\n        });\n        var tmp = reqStringify(jsonStringifiedParams);\n        serializedParams = tmp;\n      }\n    }\n  }\n\n  return serializedParams;\n} // 对请求参数做处理，实现 query 简化、 post 简化\n\nfunction simpleGetMiddleware(ctx, next) {\n  if (!ctx) return next();\n  var _ctx$req = ctx.req;\n  _ctx$req = _ctx$req === void 0 ? {} : _ctx$req;\n  var _ctx$req$options = _ctx$req.options,\n      options = _ctx$req$options === void 0 ? {} : _ctx$req$options;\n  var paramsSerializer = options.paramsSerializer,\n      params = options.params;\n  var _ctx$req2 = ctx.req;\n  _ctx$req2 = _ctx$req2 === void 0 ? {} : _ctx$req2;\n  var _ctx$req2$url = _ctx$req2.url,\n      url = _ctx$req2$url === void 0 ? '' : _ctx$req2$url; // 将 method 改为大写\n\n  options.method = options.method ? options.method.toUpperCase() : 'GET'; // 设置 credentials 默认值为 same-origin，确保当开发者没有设置时，各浏览器对请求是否发送 cookies 保持一致的行为\n  // - omit: 从不发送cookies.\n  // - same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)\n  // - include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息.\n\n  options.credentials = options.credentials || 'same-origin'; // 支持类似axios 参数自动拼装, 其他method也可用, 不冲突.\n\n  var serializedParams = paramsSerialize(params, paramsSerializer);\n  ctx.req.originUrl = url;\n\n  if (serializedParams) {\n    var urlSign = url.indexOf('?') !== -1 ? '&' : '?';\n    ctx.req.url = \"\".concat(url).concat(urlSign).concat(serializedParams);\n  }\n\n  ctx.req.options = options;\n  return next();\n}\n\nvar globalMiddlewares = [simplePostMiddleware, simpleGetMiddleware, parseResponseMiddleware];\nvar coreMiddlewares = [fetchMiddleware];\nOnion.globalMiddlewares = globalMiddlewares;\nOnion.defaultGlobalMiddlewaresLength = globalMiddlewares.length;\nOnion.coreMiddlewares = coreMiddlewares;\nOnion.defaultCoreMiddlewaresLength = coreMiddlewares.length;\n\nvar Core = /*#__PURE__*/function () {\n  function Core(initOptions) {\n    _classCallCheck(this, Core);\n\n    this.onion = new Onion([]);\n    this.fetchIndex = 0; // 【即将废弃】请求中间件位置\n\n    this.mapCache = new MapCache(initOptions);\n    this.initOptions = initOptions;\n    this.instanceRequestInterceptors = [];\n    this.instanceResponseInterceptors = [];\n  } // 旧版拦截器为共享\n\n\n  _createClass(Core, [{\n    key: \"use\",\n    value: function use(newMiddleware) {\n      var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        global: false,\n        core: false\n      };\n      this.onion.use(newMiddleware, opt);\n      return this;\n    }\n  }, {\n    key: \"extendOptions\",\n    value: function extendOptions(options) {\n      this.initOptions = mergeRequestOptions(this.initOptions, options);\n      this.mapCache.extendOptions(options);\n    } // 执行请求前拦截器\n\n  }, {\n    key: \"dealRequestInterceptors\",\n    value: function dealRequestInterceptors(ctx) {\n      var reducer = function reducer(p1, p2) {\n        return p1.then(function () {\n          var ret = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          ctx.req.url = ret.url || ctx.req.url;\n          ctx.req.options = ret.options || ctx.req.options;\n          return p2(ctx.req.url, ctx.req.options);\n        });\n      };\n\n      var allInterceptors = [].concat(_toConsumableArray(Core.requestInterceptors), _toConsumableArray(this.instanceRequestInterceptors));\n      return allInterceptors.reduce(reducer, Promise.resolve()).then(function () {\n        var ret = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        ctx.req.url = ret.url || ctx.req.url;\n        ctx.req.options = ret.options || ctx.req.options;\n        return Promise.resolve();\n      });\n    }\n  }, {\n    key: \"request\",\n    value: function request(url, options) {\n      var _this = this;\n\n      var onion = this.onion;\n      var obj = {\n        req: {\n          url: url,\n          options: _objectSpread2(_objectSpread2({}, options), {}, {\n            url: url\n          })\n        },\n        res: null,\n        cache: this.mapCache,\n        responseInterceptors: [].concat(_toConsumableArray(Core.responseInterceptors), _toConsumableArray(this.instanceResponseInterceptors))\n      };\n\n      if (typeof url !== 'string') {\n        throw new Error('url MUST be a string');\n      }\n\n      return new Promise(function (resolve, reject) {\n        _this.dealRequestInterceptors(obj).then(function () {\n          return onion.execute(obj);\n        }).then(function () {\n          resolve(obj.res);\n        }).catch(function (error) {\n          var errorHandler = obj.req.options.errorHandler;\n\n          if (errorHandler) {\n            try {\n              var data = errorHandler(error);\n              resolve(data);\n            } catch (e) {\n              reject(e);\n            }\n          } else {\n            reject(error);\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"requestUse\",\n    value: // 请求拦截器 默认 { global: true } 兼容旧版本拦截器\n    function requestUse(handler) {\n      var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        global: true\n      };\n      if (typeof handler !== 'function') throw new TypeError('Interceptor must be function!');\n\n      if (opt.global) {\n        Core.requestInterceptors.push(handler);\n      } else {\n        this.instanceRequestInterceptors.push(handler);\n      }\n    } // 响应拦截器 默认 { global: true } 兼容旧版本拦截器\n\n  }, {\n    key: \"responseUse\",\n    value: function responseUse(handler) {\n      var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        global: true\n      };\n      if (typeof handler !== 'function') throw new TypeError('Interceptor must be function!');\n\n      if (opt.global) {\n        Core.responseInterceptors.push(handler);\n      } else {\n        this.instanceResponseInterceptors.push(handler);\n      }\n    }\n  }]);\n\n  return Core;\n}();\n\nCore.requestInterceptors = [addfix];\nCore.responseInterceptors = [];\n\n/**\n * 当执行 “取消请求” 操作时会抛出 Cancel 对象作为一场\n * @class\n * @param {string=} message The message.\n */\n\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return this.message ? \"Cancel: \".concat(this.message) : 'Cancel';\n};\n\nCancel.prototype.__CANCEL__ = true;\n\n/**\n * 通过 CancelToken 来取消请求操作\n *\n * @class\n * @param {Function} executor The executor function.\n */\n\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // 取消操作已被调用过\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n/**\n * 如果请求已经取消，抛出 Cancel 异常\n */\n\n\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n/**\n * 通过 source 来返回 CancelToken 实例和取消 CancelToken 的函数\n */\n\n\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nfunction isCancel(value) {\n  return !!(value && value.__CANCEL__);\n}\n\nvar request = function request() {\n  var initOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var coreInstance = new Core(initOptions);\n\n  var umiInstance = function umiInstance(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var mergeOptions = mergeRequestOptions(coreInstance.initOptions, options);\n    return coreInstance.request(url, mergeOptions);\n  }; // 中间件\n\n\n  umiInstance.use = coreInstance.use.bind(coreInstance);\n  umiInstance.fetchIndex = coreInstance.fetchIndex; // 拦截器\n\n  umiInstance.interceptors = {\n    request: {\n      use: Core.requestUse.bind(coreInstance)\n    },\n    response: {\n      use: Core.responseUse.bind(coreInstance)\n    }\n  }; // 请求语法糖： reguest.get request.post ……\n\n  var METHODS = ['get', 'post', 'delete', 'put', 'patch', 'head', 'options', 'rpc'];\n  METHODS.forEach(function (method) {\n    umiInstance[method] = function (url, options) {\n      return umiInstance(url, _objectSpread2(_objectSpread2({}, options), {}, {\n        method: method\n      }));\n    };\n  });\n  umiInstance.Cancel = Cancel;\n  umiInstance.CancelToken = CancelToken;\n  umiInstance.isCancel = isCancel;\n  umiInstance.extendOptions = coreInstance.extendOptions.bind(coreInstance); // 暴露各个实例的中间件，供开发者自由组合\n\n  umiInstance.middlewares = {\n    instance: coreInstance.onion.middlewares,\n    defaultInstance: coreInstance.onion.defaultMiddlewares,\n    global: Onion.globalMiddlewares,\n    core: Onion.coreMiddlewares\n  };\n  return umiInstance;\n};\n/**\n * extend 方法参考了ky, 让用户可以定制配置.\n * initOpions 初始化参数\n * @param {number} maxCache 最大缓存数\n * @param {string} prefix url前缀\n * @param {function} errorHandler 统一错误处理方法\n * @param {object} headers 统一的headers\n */\n\n\nvar extend = function extend(initOptions) {\n  return request(initOptions);\n};\n/**\n * 暴露 fetch 中间件，保障依旧可以使用\n */\n\nvar fetch$1 = request({\n  parseResponse: false\n});\nvar request$1 = request({});\n\nexports.Onion = Onion;\nexports.RequestError = RequestError;\nexports.ResponseError = ResponseError;\nexports[\"default\"] = request$1;\nexports.extend = extend;\nexports.fetch = fetch$1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW1pLXJlcXVlc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFNBQVMsbUJBQU8sQ0FBQyxnREFBSTtBQUNyQixtQkFBTyxDQUFDLGlGQUFrQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGFBQW9CO0FBQzFELHdJQUF3SSxZQUFZO0FBQ3BKOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRTs7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QUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsOERBQThELGNBQWM7QUFDNUU7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25COzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7O0FBRTFCLGFBQWE7QUFDYixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLGtCQUFlO0FBQ2YsY0FBYztBQUNkLGFBQWEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9va2Jvb2tzaG9wbmcvLi9ub2RlX21vZHVsZXMvdW1pLXJlcXVlc3QvZGlzdC9pbmRleC5qcz81Y2YyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHFzID0gcmVxdWlyZSgncXMnKTtcbnJlcXVpcmUoJ2lzb21vcnBoaWMtZmV0Y2gnKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkge1xuICB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7XG4gICAgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLFxuICAgICAgICByZXN1bHQ7XG5cbiAgICBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkge1xuICAgICAgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcblxuICAgICAgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG4vLyDov5Tlm57kuIDkuKrnu4TlkIjkuobmiYDmnInmj5Lku7bnmoTigJzmj5Lku7bigJ1cbmZ1bmN0aW9uIGNvbXBvc2UobWlkZGxld2FyZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1pZGRsZXdhcmVzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlkZGxld2FyZXMgbXVzdCBiZSBhbiBhcnJheSEnKTtcbiAgdmFyIG1pZGRsZXdhcmVzTGVuID0gbWlkZGxld2FyZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWlkZGxld2FyZXNMZW47IGkrKykge1xuICAgIGlmICh0eXBlb2YgbWlkZGxld2FyZXNbaV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pZGRsZXdhcmUgbXVzdCBiZSBjb21wb25zZWQgb2YgZnVuY3Rpb24nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gd3JhcE1pZGRsZXdhcmVzKHBhcmFtcywgbmV4dCkge1xuICAgIHZhciBpbmRleCA9IC0xO1xuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2goaSkge1xuICAgICAgaWYgKGkgPD0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignbmV4dCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIGluIG9uZSBtaWRkbGV3YXJlIScpKTtcbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBpO1xuICAgICAgdmFyIGZuID0gbWlkZGxld2FyZXNbaV0gfHwgbmV4dDtcbiAgICAgIGlmICghZm4pIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmbihwYXJhbXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goaSArIDEpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpc3BhdGNoKDApO1xuICB9O1xufVxuXG52YXIgT25pb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPbmlvbihkZWZhdWx0TWlkZGxld2FyZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT25pb24pO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRlZmF1bHRNaWRkbGV3YXJlcykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlZmF1bHQgbWlkZGxld2FyZXMgbXVzdCBiZSBhbiBhcnJheSEnKTtcbiAgICB0aGlzLmRlZmF1bHRNaWRkbGV3YXJlcyA9IF90b0NvbnN1bWFibGVBcnJheShkZWZhdWx0TWlkZGxld2FyZXMpO1xuICAgIHRoaXMubWlkZGxld2FyZXMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPbmlvbiwgW3tcbiAgICBrZXk6IFwidXNlXCIsXG4gICAgdmFsdWU6IC8vIOWGhee9ruWGheaguOS4remXtOS7tumVv+W6plxuICAgIGZ1bmN0aW9uIHVzZShuZXdNaWRkbGV3YXJlKSB7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgICBjb3JlOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdEluc3RhbmNlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBjb3JlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsID0gZmFsc2U7XG4gICAgICB2YXIgZGVmYXVsdEluc3RhbmNlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ3VzZSgpIG9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCwgbnVtYmVyIHByb3BlcnR5IHdvdWxkIGJlIGRlcHJlY2F0ZWQgaW4gZnV0dXJl77yMcGxlYXNlIHVwZGF0ZSB1c2UoKSBvcHRpb25zIHRvIFwieyBjb3JlOiB0cnVlIH1cIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvcmUgPSB0cnVlO1xuICAgICAgICBnbG9iYWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRzKSA9PT0gJ29iamVjdCcgJiYgb3B0cykge1xuICAgICAgICBnbG9iYWwgPSBvcHRzLmdsb2JhbCB8fCBmYWxzZTtcbiAgICAgICAgY29yZSA9IG9wdHMuY29yZSB8fCBmYWxzZTtcbiAgICAgICAgZGVmYXVsdEluc3RhbmNlID0gb3B0cy5kZWZhdWx0SW5zdGFuY2UgfHwgZmFsc2U7XG4gICAgICB9IC8vIOWFqOWxgOS4remXtOS7tlxuXG5cbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgT25pb24uZ2xvYmFsTWlkZGxld2FyZXMuc3BsaWNlKE9uaW9uLmdsb2JhbE1pZGRsZXdhcmVzLmxlbmd0aCAtIE9uaW9uLmRlZmF1bHRHbG9iYWxNaWRkbGV3YXJlc0xlbmd0aCwgMCwgbmV3TWlkZGxld2FyZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8g5YaF5qC45Lit6Ze05Lu2XG5cblxuICAgICAgaWYgKGNvcmUpIHtcbiAgICAgICAgT25pb24uY29yZU1pZGRsZXdhcmVzLnNwbGljZShPbmlvbi5jb3JlTWlkZGxld2FyZXMubGVuZ3RoIC0gT25pb24uZGVmYXVsdENvcmVNaWRkbGV3YXJlc0xlbmd0aCwgMCwgbmV3TWlkZGxld2FyZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8g6buY6K6k5a6e5L6L5Lit6Ze05Lu277yM5L6b5byA5Y+R6ICF5L2/55SoXG5cblxuICAgICAgaWYgKGRlZmF1bHRJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRNaWRkbGV3YXJlcy5wdXNoKG5ld01pZGRsZXdhcmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIOWunuS+i+S4remXtOS7tlxuXG5cbiAgICAgIHRoaXMubWlkZGxld2FyZXMucHVzaChuZXdNaWRkbGV3YXJlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXhlY3V0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHZhciBmbiA9IGNvbXBvc2UoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLm1pZGRsZXdhcmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuZGVmYXVsdE1pZGRsZXdhcmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9uaW9uLmdsb2JhbE1pZGRsZXdhcmVzKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9uaW9uLmNvcmVNaWRkbGV3YXJlcykpKTtcbiAgICAgIHJldHVybiBmbihwYXJhbXMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPbmlvbjtcbn0oKTtcblxuT25pb24uZ2xvYmFsTWlkZGxld2FyZXMgPSBbXTtcbk9uaW9uLmRlZmF1bHRHbG9iYWxNaWRkbGV3YXJlc0xlbmd0aCA9IDA7XG5Pbmlvbi5jb3JlTWlkZGxld2FyZXMgPSBbXTtcbk9uaW9uLmRlZmF1bHRDb3JlTWlkZGxld2FyZXNMZW5ndGggPSAwO1xuXG52YXIgTWFwQ2FjaGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXBDYWNoZShvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcENhY2hlKTtcblxuICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50aW1lciA9IHt9O1xuICAgIHRoaXMuZXh0ZW5kT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBDYWNoZSwgW3tcbiAgICBrZXk6IFwiZXh0ZW5kT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMubWF4Q2FjaGUgPSBvcHRpb25zLm1heENhY2hlIHx8IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoSlNPTi5zdHJpbmdpZnkoa2V5KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHR0bCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogNjAwMDA7XG5cbiAgICAgIC8vIOWmguaenOi2hei/h+acgOWkp+e8k+WtmOaVsCwg5Yig6Zmk5aS06YOo55qE56ys5LiA5Liq57yT5a2YLlxuICAgICAgaWYgKHRoaXMubWF4Q2FjaGUgPiAwICYmIHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heENhY2hlKSB7XG4gICAgICAgIHZhciBkZWxldGVLZXkgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5jYWNoZS5rZXlzKCkpWzBdO1xuXG4gICAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGRlbGV0ZUtleSk7XG5cbiAgICAgICAgaWYgKHRoaXMudGltZXJbZGVsZXRlS2V5XSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyW2RlbGV0ZUtleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwgdmFsdWUpO1xuXG4gICAgICBpZiAodHRsID4gMCkge1xuICAgICAgICB0aGlzLnRpbWVyW2NhY2hlS2V5XSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmNhY2hlLmRlbGV0ZShjYWNoZUtleSk7XG5cbiAgICAgICAgICBkZWxldGUgX3RoaXMudGltZXJbY2FjaGVLZXldO1xuICAgICAgICB9LCB0dGwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICBkZWxldGUgdGhpcy50aW1lcltjYWNoZUtleV07XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMudGltZXIgPSB7fTtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hcENhY2hlO1xufSgpO1xuLyoqXG4gKiDor7fmsYLlvILluLhcbiAqL1xuXG52YXIgUmVxdWVzdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IpIHtcbiAgX2luaGVyaXRzKFJlcXVlc3RFcnJvciwgX0Vycm9yKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlcXVlc3RFcnJvcik7XG5cbiAgZnVuY3Rpb24gUmVxdWVzdEVycm9yKHRleHQsIHJlcXVlc3QpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdSZXF1ZXN0RXJyb3InO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcXVlc3RFcnJvcik7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIuY2FsbCh0aGlzLCB0ZXh0KTtcbiAgICBfdGhpczIubmFtZSA9ICdSZXF1ZXN0RXJyb3InO1xuICAgIF90aGlzMi5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICBfdGhpczIudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBSZXF1ZXN0RXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuLyoqXG4gKiDlk43lupTlvILluLhcbiAqL1xuXG52YXIgUmVzcG9uc2VFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yMikge1xuICBfaW5oZXJpdHMoUmVzcG9uc2VFcnJvciwgX0Vycm9yMik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoUmVzcG9uc2VFcnJvcik7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgdGV4dCwgZGF0YSwgcmVxdWVzdCkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJ1Jlc3BvbnNlRXJyb3InO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNlRXJyb3IpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyMi5jYWxsKHRoaXMsIHRleHQgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgX3RoaXMzLm5hbWUgPSAnUmVzcG9uc2VFcnJvcic7XG4gICAgX3RoaXMzLmRhdGEgPSBkYXRhO1xuICAgIF90aGlzMy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIF90aGlzMy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICBfdGhpczMudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBSZXNwb25zZUVycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbi8qKlxuICogaHR0cDovL2dpdGxhYi5hbGlwYXktaW5jLmNvbS9LQlNKL2d4dC9ibG9iL3JlbGVhc2VfZ3h0X1M4OTI4OTA1XzIwMTgwNTMxL3NyYy91dGlsL3JlcXVlc3QuanMjTDYzXG4gKiDmlK/mjIFnYmtcbiAqL1xuXG5mdW5jdGlvbiByZWFkZXJHQksoZmlsZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgfTtcblxuICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUsICdHQksnKTsgLy8gc2V0dXAgR0JLIGRlY29kaW5nXG4gIH0pO1xufVxuLyoqXG4gKiDlronlhajnmoRKU09OLnBhcnNlXG4gKi9cblxuZnVuY3Rpb24gc2FmZUpzb25QYXJzZShkYXRhKSB7XG4gIHZhciB0aHJvd0VycklmUGFyc2VGYWlsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIHJlc3BvbnNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICB2YXIgcmVxdWVzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRocm93RXJySWZQYXJzZUZhaWwpIHtcbiAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKHJlc3BvbnNlLCAnSlNPTi5wYXJzZSBmYWlsJywgZGF0YSwgcmVxdWVzdCwgJ1BhcnNlRXJyb3InKTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG5cbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiB0aW1lb3V0MlRocm93KG1zZWMsIHRpbWVvdXRNZXNzYWdlLCByZXF1ZXN0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZWplY3QobmV3IFJlcXVlc3RFcnJvcih0aW1lb3V0TWVzc2FnZSB8fCBcInRpbWVvdXQgb2YgXCIuY29uY2F0KG1zZWMsIFwibXMgZXhjZWVkZWRcIiksIHJlcXVlc3QsICdUaW1lb3V0JykpO1xuICAgIH0sIG1zZWMpO1xuICB9KTtcbn0gLy8gSWYgcmVxdWVzdCBvcHRpb25zIGNvbnRhaW4gJ2NhbmNlbFRva2VuJywgcmVqZWN0IHJlcXVlc3Qgd2hlbiB0b2tlbiBoYXMgYmVlbiBjYW5jZWxlZFxuXG5mdW5jdGlvbiBjYW5jZWwyVGhyb3cob3B0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgaWYgKG9wdC5jYW5jZWxUb2tlbikge1xuICAgICAgb3B0LmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiAoY2FuY2VsKSB7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7IC8vIENoZWNrIGVudiBpcyBicm93c2VyIG9yIG5vZGVcblxuZnVuY3Rpb24gZ2V0RW52KCkge1xuICB2YXIgZW52OyAvLyBPbmx5IE5vZGUuSlMgaGFzIGEgcHJvY2VzcyB2YXJpYWJsZSB0aGF0IGlzIG9mIFtbQ2xhc3NdXSBwcm9jZXNzXG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgZW52ID0gJ05PREUnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbnYgPSAnQlJPV1NFUic7XG4gIH1cblxuICByZXR1cm4gZW52O1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBmb3JFYWNoMk9iakFycih0YXJnZXQsIGNhbGxiYWNrKSB7XG4gIGlmICghdGFyZ2V0KSByZXR1cm47XG5cbiAgaWYgKF90eXBlb2YodGFyZ2V0KSAhPT0gJ29iamVjdCcpIHtcbiAgICB0YXJnZXQgPSBbdGFyZ2V0XTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2suY2FsbChudWxsLCB0YXJnZXRbaV0sIGksIHRhcmdldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgdGFyZ2V0W2tleV0sIGtleSwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBhcmFtT2JqZWN0KHZhbCkge1xuICBpZiAoaXNVUkxTZWFyY2hQYXJhbXModmFsKSkge1xuICAgIHJldHVybiBxcy5wYXJzZSh2YWwudG9TdHJpbmcoKSwge1xuICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW3ZhbF07XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gcmVxU3RyaW5naWZ5KHZhbCkge1xuICByZXR1cm4gcXMuc3RyaW5naWZ5KHZhbCwge1xuICAgIGFycmF5Rm9ybWF0OiAncmVwZWF0JyxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMsIG9wdGlvbnMyTWVyZ2UpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwgb3B0aW9uczJNZXJnZSksIHt9LCB7XG4gICAgaGVhZGVyczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMuaGVhZGVycyksIG9wdGlvbnMyTWVyZ2UuaGVhZGVycyksXG4gICAgcGFyYW1zOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZ2V0UGFyYW1PYmplY3Qob3B0aW9ucy5wYXJhbXMpKSwgZ2V0UGFyYW1PYmplY3Qob3B0aW9uczJNZXJnZS5wYXJhbXMpKSxcbiAgICBtZXRob2Q6IChvcHRpb25zMk1lcmdlLm1ldGhvZCB8fCBvcHRpb25zLm1ldGhvZCB8fCAnZ2V0JykudG9Mb3dlckNhc2UoKVxuICB9KTtcbn1cblxuLy8g5YmN5ZCO57yA5oum5oiqXG52YXIgYWRkZml4ID0gZnVuY3Rpb24gYWRkZml4KHVybCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBwcmVmaXggPSBvcHRpb25zLnByZWZpeCxcbiAgICAgIHN1ZmZpeCA9IG9wdGlvbnMuc3VmZml4O1xuXG4gIGlmIChwcmVmaXgpIHtcbiAgICB1cmwgPSBcIlwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdCh1cmwpO1xuICB9XG5cbiAgaWYgKHN1ZmZpeCkge1xuICAgIHVybCA9IFwiXCIuY29uY2F0KHVybCkuY29uY2F0KHN1ZmZpeCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHVybDogdXJsLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbn07XG5cbnZhciB3YXJuZWRDb3JlVHlwZSA9IGZhbHNlOyAvLyDpu5jorqTnvJPlrZjliKTmlq3vvIzlvIDmlL7nvJPlrZjliKTmlq3nu5npnZ4gZ2V0IOivt+axguS9v+eUqFxuXG5mdW5jdGlvbiBfX2RlZmF1bHRWYWxpZGF0ZUNhY2hlKHVybCwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkbWV0aG9kID0gb3B0aW9ucy5tZXRob2QsXG4gICAgICBtZXRob2QgPSBfb3B0aW9ucyRtZXRob2QgPT09IHZvaWQgMCA/ICdnZXQnIDogX29wdGlvbnMkbWV0aG9kO1xuICByZXR1cm4gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09ICdnZXQnO1xufVxuXG5mdW5jdGlvbiBmZXRjaE1pZGRsZXdhcmUoY3R4LCBuZXh0KSB7XG4gIGlmICghY3R4KSByZXR1cm4gbmV4dCgpO1xuICB2YXIgX2N0eCRyZXEgPSBjdHgucmVxO1xuICBfY3R4JHJlcSA9IF9jdHgkcmVxID09PSB2b2lkIDAgPyB7fSA6IF9jdHgkcmVxO1xuICB2YXIgX2N0eCRyZXEkb3B0aW9ucyA9IF9jdHgkcmVxLm9wdGlvbnMsXG4gICAgICBvcHRpb25zID0gX2N0eCRyZXEkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfY3R4JHJlcSRvcHRpb25zLFxuICAgICAgX2N0eCRyZXEkdXJsID0gX2N0eCRyZXEudXJsLFxuICAgICAgdXJsID0gX2N0eCRyZXEkdXJsID09PSB2b2lkIDAgPyAnJyA6IF9jdHgkcmVxJHVybCxcbiAgICAgIGNhY2hlID0gY3R4LmNhY2hlLFxuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvcnMgPSBjdHgucmVzcG9uc2VJbnRlcmNlcHRvcnM7XG5cbiAgdmFyIF9vcHRpb25zJHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQsXG4gICAgICB0aW1lb3V0ID0gX29wdGlvbnMkdGltZW91dCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRpbWVvdXQsXG4gICAgICB0aW1lb3V0TWVzc2FnZSA9IG9wdGlvbnMudGltZW91dE1lc3NhZ2UsXG4gICAgICBfb3B0aW9ucyRfX3VtaVJlcXVlc3QgPSBvcHRpb25zLl9fdW1pUmVxdWVzdENvcmVUeXBlX18sXG4gICAgICBfX3VtaVJlcXVlc3RDb3JlVHlwZV9fID0gX29wdGlvbnMkX191bWlSZXF1ZXN0ID09PSB2b2lkIDAgPyAnbm9ybWFsJyA6IF9vcHRpb25zJF9fdW1pUmVxdWVzdCxcbiAgICAgIF9vcHRpb25zJHVzZUNhY2hlID0gb3B0aW9ucy51c2VDYWNoZSxcbiAgICAgIHVzZUNhY2hlID0gX29wdGlvbnMkdXNlQ2FjaGUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkdXNlQ2FjaGUsXG4gICAgICBfb3B0aW9ucyRtZXRob2QyID0gb3B0aW9ucy5tZXRob2QsXG4gICAgICBtZXRob2QgPSBfb3B0aW9ucyRtZXRob2QyID09PSB2b2lkIDAgPyAnZ2V0JyA6IF9vcHRpb25zJG1ldGhvZDIsXG4gICAgICBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyxcbiAgICAgIHR0bCA9IG9wdGlvbnMudHRsLFxuICAgICAgX29wdGlvbnMkdmFsaWRhdGVDYWNoID0gb3B0aW9ucy52YWxpZGF0ZUNhY2hlLFxuICAgICAgdmFsaWRhdGVDYWNoZSA9IF9vcHRpb25zJHZhbGlkYXRlQ2FjaCA9PT0gdm9pZCAwID8gX19kZWZhdWx0VmFsaWRhdGVDYWNoZSA6IF9vcHRpb25zJHZhbGlkYXRlQ2FjaDtcblxuICBpZiAoX191bWlSZXF1ZXN0Q29yZVR5cGVfXyAhPT0gJ25vcm1hbCcpIHtcbiAgICBpZiAocHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiB3YXJuZWRDb3JlVHlwZSA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZENvcmVUeXBlID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUud2FybignX191bWlSZXF1ZXN0Q29yZVR5cGVfXyBpcyBhIGludGVybmFsIHByb3BlcnR5IHRoYXQgdXNlIGluIHVtaS1yZXF1ZXN0LCBjaGFuZ2UgaXRzIHZhbHVlIHdvdWxkIGFmZmVjdCB0aGUgYmVoYXZpb3Igb2YgcmVxdWVzdCEgSXQgb25seSB1c2Ugd2hlbiB5b3Ugd2FudCB0byBleHRlbmQgb3IgdXNlIHJlcXVlc3QgY29yZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG5cbiAgdmFyIGFkYXB0ZXIgPSBmZXRjaDtcblxuICBpZiAoIWFkYXB0ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dsb2JhbCBmZXRjaCBub3QgZXhpc3QhJyk7XG4gIH0gLy8g5LuO57yT5a2Y5rGg5qOA5p+l5piv5ZCm5pyJ57yT5a2Y5pWw5o2uXG5cblxuICB2YXIgaXNCcm93c2VyID0gZ2V0RW52KCkgPT09ICdCUk9XU0VSJztcbiAgdmFyIG5lZWRDYWNoZSA9IHZhbGlkYXRlQ2FjaGUodXJsLCBvcHRpb25zKSAmJiB1c2VDYWNoZSAmJiBpc0Jyb3dzZXI7XG5cbiAgaWYgKG5lZWRDYWNoZSkge1xuICAgIHZhciByZXNwb25zZUNhY2hlID0gY2FjaGUuZ2V0KHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlQ2FjaGUpIHtcbiAgICAgIHJlc3BvbnNlQ2FjaGUgPSByZXNwb25zZUNhY2hlLmNsb25lKCk7XG4gICAgICByZXNwb25zZUNhY2hlLnVzZUNhY2hlID0gdHJ1ZTtcbiAgICAgIGN0eC5yZXMgPSByZXNwb25zZUNhY2hlO1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzcG9uc2U7IC8vIOi2heaXtuWkhOeQhuOAgeWPlua2iOivt+axguWkhOeQhlxuXG4gIGlmICh0aW1lb3V0ID4gMCkge1xuICAgIHJlc3BvbnNlID0gUHJvbWlzZS5yYWNlKFtjYW5jZWwyVGhyb3cob3B0aW9ucyksIGFkYXB0ZXIodXJsLCBvcHRpb25zKSwgdGltZW91dDJUaHJvdyh0aW1lb3V0LCB0aW1lb3V0TWVzc2FnZSwgY3R4LnJlcSldKTtcbiAgfSBlbHNlIHtcbiAgICByZXNwb25zZSA9IFByb21pc2UucmFjZShbY2FuY2VsMlRocm93KG9wdGlvbnMpLCBhZGFwdGVyKHVybCwgb3B0aW9ucyldKTtcbiAgfSAvLyDlhbzlrrnogIHniYjmnKwgcmVzcG9uc2UuaW50ZXJjZXB0b3JcblxuXG4gIHJlc3BvbnNlSW50ZXJjZXB0b3JzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICByZXNwb25zZSA9IHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gRml4IG11bHRpcGxlIGNsb25lcyBub3Qgd29ya2luZywgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzUwNFxuICAgICAgdmFyIGNsb25lZFJlcyA9IHR5cGVvZiByZXMuY2xvbmUgPT09ICdmdW5jdGlvbicgPyByZXMuY2xvbmUoKSA6IHJlcztcbiAgICAgIHJldHVybiBoYW5kbGVyKGNsb25lZFJlcywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgLy8g5piv5ZCm5a2Y5YWl57yT5a2Y5rGgXG4gICAgaWYgKG5lZWRDYWNoZSkge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICB2YXIgY29weSA9IHJlcy5jbG9uZSgpO1xuICAgICAgICBjb3B5LnVzZUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgY2FjaGUuc2V0KHtcbiAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICAgICB9LCBjb3B5LCB0dGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5yZXMgPSByZXM7XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VNaWRkbGV3YXJlKGN0eCwgbmV4dCkge1xuICB2YXIgY29weTtcbiAgcmV0dXJuIG5leHQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xuICAgIHZhciBfY3R4JHJlcyA9IGN0eC5yZXMsXG4gICAgICAgIHJlcyA9IF9jdHgkcmVzID09PSB2b2lkIDAgPyB7fSA6IF9jdHgkcmVzLFxuICAgICAgICBfY3R4JHJlcSA9IGN0eC5yZXEsXG4gICAgICAgIHJlcSA9IF9jdHgkcmVxID09PSB2b2lkIDAgPyB7fSA6IF9jdHgkcmVxO1xuXG4gICAgdmFyIF9yZWYgPSByZXEgfHwge30sXG4gICAgICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcblxuICAgIF9yZWYkb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnM7XG4gICAgdmFyIF9yZWYkb3B0aW9ucyRyZXNwb25zZSA9IF9yZWYkb3B0aW9ucy5yZXNwb25zZVR5cGUsXG4gICAgICAgIHJlc3BvbnNlVHlwZSA9IF9yZWYkb3B0aW9ucyRyZXNwb25zZSA9PT0gdm9pZCAwID8gJ2pzb24nIDogX3JlZiRvcHRpb25zJHJlc3BvbnNlLFxuICAgICAgICBfcmVmJG9wdGlvbnMkY2hhcnNldCA9IF9yZWYkb3B0aW9ucy5jaGFyc2V0LFxuICAgICAgICBjaGFyc2V0ID0gX3JlZiRvcHRpb25zJGNoYXJzZXQgPT09IHZvaWQgMCA/ICd1dGY4JyA6IF9yZWYkb3B0aW9ucyRjaGFyc2V0LFxuICAgICAgICBfcmVmJG9wdGlvbnMkZ2V0UmVzcG8gPSBfcmVmJG9wdGlvbnMuZ2V0UmVzcG9uc2UsXG4gICAgICAgIF9yZWYkb3B0aW9ucyR0aHJvd0VyciA9IF9yZWYkb3B0aW9ucy50aHJvd0VycklmUGFyc2VGYWlsLFxuICAgICAgICB0aHJvd0VycklmUGFyc2VGYWlsID0gX3JlZiRvcHRpb25zJHRocm93RXJyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkb3B0aW9ucyR0aHJvd0VycixcbiAgICAgICAgX3JlZiRvcHRpb25zJHBhcnNlUmVzID0gX3JlZiRvcHRpb25zLnBhcnNlUmVzcG9uc2UsXG4gICAgICAgIHBhcnNlUmVzcG9uc2UgPSBfcmVmJG9wdGlvbnMkcGFyc2VSZXMgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJG9wdGlvbnMkcGFyc2VSZXM7XG5cbiAgICBpZiAoIXBhcnNlUmVzcG9uc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXJlcyB8fCAhcmVzLmNsb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlj6rlnKjmtY/op4jlmajnjq/looPlr7kgcmVzcG9uc2Ug5YGa5YWL6ZqG77yMIG5vZGUg546v5aKD5aaC5p6c5a+5IHJlc3BvbnNlIOWFi+mahuS8muaciemXrumimO+8mmh0dHBzOi8vZ2l0aHViLmNvbS9iaXRpbm4vbm9kZS1mZXRjaC9pc3N1ZXMvNTUzXG5cblxuICAgIGNvcHkgPSBnZXRFbnYoKSA9PT0gJ0JST1dTRVInID8gcmVzLmNsb25lKCkgOiByZXM7XG4gICAgY29weS51c2VDYWNoZSA9IHJlcy51c2VDYWNoZSB8fCBmYWxzZTsgLy8g6Kej5p6Q5pWw5o2uXG5cbiAgICBpZiAoY2hhcnNldCA9PT0gJ2diaycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXMuYmxvYigpLnRoZW4ocmVhZGVyR0JLKS50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIHNhZmVKc29uUGFyc2UoZCwgZmFsc2UsIGNvcHksIHJlcSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihjb3B5LCBlLm1lc3NhZ2UsIG51bGwsIHJlcSwgJ1BhcnNlRXJyb3InKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBzYWZlSnNvblBhcnNlKGQsIHRocm93RXJySWZQYXJzZUZhaWwsIGNvcHksIHJlcSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8g5YW25LuW5aaCdGV4dCwgYmxvYiwgYXJyYXlCdWZmZXIsIGZvcm1EYXRhXG4gICAgICByZXR1cm4gcmVzW3Jlc3BvbnNlVHlwZV0oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgUmVzcG9uc2VFcnJvcihjb3B5LCAncmVzcG9uc2VUeXBlIG5vdCBzdXBwb3J0JywgbnVsbCwgcmVxLCAnUGFyc2VFcnJvcicpO1xuICAgIH1cbiAgfSkudGhlbihmdW5jdGlvbiAoYm9keSkge1xuICAgIGlmICghY3R4KSByZXR1cm47XG4gICAgdmFyIF9jdHgkcmVzMiA9IGN0eC5yZXMsXG4gICAgICAgIF9jdHgkcmVxMiA9IGN0eC5yZXEsXG4gICAgICAgIHJlcSA9IF9jdHgkcmVxMiA9PT0gdm9pZCAwID8ge30gOiBfY3R4JHJlcTI7XG5cbiAgICB2YXIgX3JlZjIgPSByZXEgfHwge30sXG4gICAgICAgIF9yZWYyJG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuXG4gICAgX3JlZjIkb3B0aW9ucyA9IF9yZWYyJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIkb3B0aW9ucztcbiAgICB2YXIgX3JlZjIkb3B0aW9ucyRnZXRSZXNwID0gX3JlZjIkb3B0aW9ucy5nZXRSZXNwb25zZSxcbiAgICAgICAgZ2V0UmVzcG9uc2UgPSBfcmVmMiRvcHRpb25zJGdldFJlc3AgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkb3B0aW9ucyRnZXRSZXNwO1xuXG4gICAgaWYgKCFjb3B5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvcHkuc3RhdHVzID49IDIwMCAmJiBjb3B5LnN0YXR1cyA8IDMwMCkge1xuICAgICAgLy8g5o+Q5L6b5rqQcmVzcG9uc2UsIOS7peS+v+iHquWumuS5ieWkhOeQhlxuICAgICAgaWYgKGdldFJlc3BvbnNlKSB7XG4gICAgICAgIGN0eC5yZXMgPSB7XG4gICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICByZXNwb25zZTogY29weVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXMgPSBib2R5O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKGNvcHksICdodHRwIGVycm9yJywgYm9keSwgcmVxLCAnSHR0cEVycm9yJyk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBSZXF1ZXN0RXJyb3IgfHwgZSBpbnN0YW5jZW9mIFJlc3BvbnNlRXJyb3IpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSAvLyDlr7nmnKrnn6XplJnor6/ov5vooYzlpITnkIZcblxuXG4gICAgdmFyIHJlcSA9IGN0eC5yZXEsXG4gICAgICAgIHJlcyA9IGN0eC5yZXM7XG4gICAgZS5yZXF1ZXN0ID0gZS5yZXF1ZXN0IHx8IHJlcTtcbiAgICBlLnJlc3BvbnNlID0gZS5yZXNwb25zZSB8fCByZXM7XG4gICAgZS50eXBlID0gZS50eXBlIHx8IGUubmFtZTtcbiAgICBlLmRhdGEgPSBlLmRhdGEgfHwgdW5kZWZpbmVkO1xuICAgIHRocm93IGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVQb3N0TWlkZGxld2FyZShjdHgsIG5leHQpIHtcbiAgaWYgKCFjdHgpIHJldHVybiBuZXh0KCk7XG4gIHZhciBfY3R4JHJlcSA9IGN0eC5yZXE7XG4gIF9jdHgkcmVxID0gX2N0eCRyZXEgPT09IHZvaWQgMCA/IHt9IDogX2N0eCRyZXE7XG4gIHZhciBfY3R4JHJlcSRvcHRpb25zID0gX2N0eCRyZXEub3B0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSBfY3R4JHJlcSRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9jdHgkcmVxJG9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRtZXRob2QgPSBvcHRpb25zLm1ldGhvZCxcbiAgICAgIG1ldGhvZCA9IF9vcHRpb25zJG1ldGhvZCA9PT0gdm9pZCAwID8gJ2dldCcgOiBfb3B0aW9ucyRtZXRob2Q7XG5cbiAgaWYgKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnZGVsZXRlJ10uaW5kZXhPZihtZXRob2QudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRyZXF1ZXN0VHlwZSA9IG9wdGlvbnMucmVxdWVzdFR5cGUsXG4gICAgICByZXF1ZXN0VHlwZSA9IF9vcHRpb25zJHJlcXVlc3RUeXBlID09PSB2b2lkIDAgPyAnanNvbicgOiBfb3B0aW9ucyRyZXF1ZXN0VHlwZSxcbiAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGE7IC8vIOaVsOaNruS9v+eUqOexu2F4aW9z55qE5paw5a2X5q61ZGF0YSwg6YG/5YWN5byV55So5ZCO5b2x5ZON5pen5Luj56CBLCDlpoLlsIZib2R5IHN0cmluZ2lmeeWkmuasoVxuXG4gIGlmIChkYXRhKSB7XG4gICAgdmFyIGRhdGFUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpO1xuXG4gICAgaWYgKGRhdGFUeXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCBkYXRhVHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgaWYgKHJlcXVlc3RUeXBlID09PSAnanNvbicpIHtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J1xuICAgICAgICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdFR5cGUgPT09ICdmb3JtJykge1xuICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCdcbiAgICAgICAgfSwgb3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gcmVxU3RyaW5naWZ5KGRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyDlhbbku5YgcmVxdWVzdFR5cGUg6Ieq5a6a5LmJaGVhZGVyXG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgb3B0aW9ucy5ib2R5ID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBjdHgucmVxLm9wdGlvbnMgPSBvcHRpb25zO1xuICByZXR1cm4gbmV4dCgpO1xufVxuXG5mdW5jdGlvbiBwYXJhbXNTZXJpYWxpemUocGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICB2YXIganNvblN0cmluZ2lmaWVkUGFyYW1zOyAvLyDmlK/mjIHlj4LmlbDoh6rliqjmi7zoo4XvvIzlhbbku5YgbWV0aG9kIOS5n+WPr+eUqO+8jOS4jeWGsueqgVxuXG4gIGlmIChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICBqc29uU3RyaW5naWZpZWRQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yRWFjaDJPYmpBcnIocGFyYW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtID09PSBudWxsIHx8IHR5cGVvZiBpdGVtID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAganNvblN0cmluZ2lmaWVkUGFyYW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGpzb25TdHJpbmdpZmllZFBhcmFtcy5wdXNoKGlzT2JqZWN0KGl0ZW0pID8gSlNPTi5zdHJpbmdpZnkoaXRlbSkgOiBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvLyBhOiBbMSwyLDNdID0+IGE9MSZhPTImYT0zXG5cbiAgICAgICAgc2VyaWFsaXplZFBhcmFtcyA9IHJlcVN0cmluZ2lmeShqc29uU3RyaW5naWZpZWRQYXJhbXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvblN0cmluZ2lmaWVkUGFyYW1zID0ge307XG4gICAgICAgIGZvckVhY2gyT2JqQXJyKHBhcmFtcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICB2YXIganNvblN0cmluZ2lmaWVkVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBqc29uU3RyaW5naWZpZWRQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAganNvblN0cmluZ2lmaWVkVmFsdWUgPSB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGpzb25TdHJpbmdpZmllZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGpzb25TdHJpbmdpZmllZFZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGpzb25TdHJpbmdpZmllZFBhcmFtc1trZXldID0ganNvblN0cmluZ2lmaWVkVmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdG1wID0gcmVxU3RyaW5naWZ5KGpzb25TdHJpbmdpZmllZFBhcmFtcyk7XG4gICAgICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRQYXJhbXM7XG59IC8vIOWvueivt+axguWPguaVsOWBmuWkhOeQhu+8jOWunueOsCBxdWVyeSDnroDljJbjgIEgcG9zdCDnroDljJZcblxuZnVuY3Rpb24gc2ltcGxlR2V0TWlkZGxld2FyZShjdHgsIG5leHQpIHtcbiAgaWYgKCFjdHgpIHJldHVybiBuZXh0KCk7XG4gIHZhciBfY3R4JHJlcSA9IGN0eC5yZXE7XG4gIF9jdHgkcmVxID0gX2N0eCRyZXEgPT09IHZvaWQgMCA/IHt9IDogX2N0eCRyZXE7XG4gIHZhciBfY3R4JHJlcSRvcHRpb25zID0gX2N0eCRyZXEub3B0aW9ucyxcbiAgICAgIG9wdGlvbnMgPSBfY3R4JHJlcSRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9jdHgkcmVxJG9wdGlvbnM7XG4gIHZhciBwYXJhbXNTZXJpYWxpemVyID0gb3B0aW9ucy5wYXJhbXNTZXJpYWxpemVyLFxuICAgICAgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gIHZhciBfY3R4JHJlcTIgPSBjdHgucmVxO1xuICBfY3R4JHJlcTIgPSBfY3R4JHJlcTIgPT09IHZvaWQgMCA/IHt9IDogX2N0eCRyZXEyO1xuICB2YXIgX2N0eCRyZXEyJHVybCA9IF9jdHgkcmVxMi51cmwsXG4gICAgICB1cmwgPSBfY3R4JHJlcTIkdXJsID09PSB2b2lkIDAgPyAnJyA6IF9jdHgkcmVxMiR1cmw7IC8vIOWwhiBtZXRob2Qg5pS55Li65aSn5YaZXG5cbiAgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJzsgLy8g6K6+572uIGNyZWRlbnRpYWxzIOm7mOiupOWAvOS4uiBzYW1lLW9yaWdpbu+8jOehruS/neW9k+W8gOWPkeiAheayoeacieiuvue9ruaXtu+8jOWQhOa1j+iniOWZqOWvueivt+axguaYr+WQpuWPkemAgSBjb29raWVzIOS/neaMgeS4gOiHtOeahOihjOS4ulxuICAvLyAtIG9taXQ6IOS7juS4jeWPkemAgWNvb2tpZXMuXG4gIC8vIC0gc2FtZS1vcmlnaW46IOWPquacieW9k1VSTOS4juWTjeW6lOiEmuacrOWQjOa6kOaJjeWPkemAgSBjb29raWVz44CBIEhUVFAgQmFzaWMgYXV0aGVudGljYXRpb24g562J6aqM6K+B5L+h5oGvLijmtY/op4jlmajpu5jorqTlgLws5Zyo5pen54mI5pys5rWP6KeI5Zmo77yM5L6L5aaCc2FmYXJpIDEx5L6d5pen5pivb21pdO+8jHNhZmFyaSAxMuW3suabtOaUuSlcbiAgLy8gLSBpbmNsdWRlOiDkuI3orrrmmK/kuI3mmK/ot6jln5/nmoTor7fmsYIs5oC75piv5Y+R6YCB6K+35rGC6LWE5rqQ5Z+f5Zyo5pys5Zyw55qEIGNvb2tpZXPjgIEgSFRUUCBCYXNpYyBhdXRoZW50aWNhdGlvbiDnrYnpqozor4Hkv6Hmga8uXG5cbiAgb3B0aW9ucy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJzsgLy8g5pSv5oyB57G75Ly8YXhpb3Mg5Y+C5pWw6Ieq5Yqo5ou86KOFLCDlhbbku5ZtZXRob2TkuZ/lj6/nlKgsIOS4jeWGsueqgS5cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZShwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpO1xuICBjdHgucmVxLm9yaWdpblVybCA9IHVybDtcblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciB1cmxTaWduID0gdXJsLmluZGV4T2YoJz8nKSAhPT0gLTEgPyAnJicgOiAnPyc7XG4gICAgY3R4LnJlcS51cmwgPSBcIlwiLmNvbmNhdCh1cmwpLmNvbmNhdCh1cmxTaWduKS5jb25jYXQoc2VyaWFsaXplZFBhcmFtcyk7XG4gIH1cblxuICBjdHgucmVxLm9wdGlvbnMgPSBvcHRpb25zO1xuICByZXR1cm4gbmV4dCgpO1xufVxuXG52YXIgZ2xvYmFsTWlkZGxld2FyZXMgPSBbc2ltcGxlUG9zdE1pZGRsZXdhcmUsIHNpbXBsZUdldE1pZGRsZXdhcmUsIHBhcnNlUmVzcG9uc2VNaWRkbGV3YXJlXTtcbnZhciBjb3JlTWlkZGxld2FyZXMgPSBbZmV0Y2hNaWRkbGV3YXJlXTtcbk9uaW9uLmdsb2JhbE1pZGRsZXdhcmVzID0gZ2xvYmFsTWlkZGxld2FyZXM7XG5Pbmlvbi5kZWZhdWx0R2xvYmFsTWlkZGxld2FyZXNMZW5ndGggPSBnbG9iYWxNaWRkbGV3YXJlcy5sZW5ndGg7XG5Pbmlvbi5jb3JlTWlkZGxld2FyZXMgPSBjb3JlTWlkZGxld2FyZXM7XG5Pbmlvbi5kZWZhdWx0Q29yZU1pZGRsZXdhcmVzTGVuZ3RoID0gY29yZU1pZGRsZXdhcmVzLmxlbmd0aDtcblxudmFyIENvcmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb3JlKGluaXRPcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvcmUpO1xuXG4gICAgdGhpcy5vbmlvbiA9IG5ldyBPbmlvbihbXSk7XG4gICAgdGhpcy5mZXRjaEluZGV4ID0gMDsgLy8g44CQ5Y2z5bCG5bqf5byD44CR6K+35rGC5Lit6Ze05Lu25L2N572uXG5cbiAgICB0aGlzLm1hcENhY2hlID0gbmV3IE1hcENhY2hlKGluaXRPcHRpb25zKTtcbiAgICB0aGlzLmluaXRPcHRpb25zID0gaW5pdE9wdGlvbnM7XG4gICAgdGhpcy5pbnN0YW5jZVJlcXVlc3RJbnRlcmNlcHRvcnMgPSBbXTtcbiAgICB0aGlzLmluc3RhbmNlUmVzcG9uc2VJbnRlcmNlcHRvcnMgPSBbXTtcbiAgfSAvLyDml6fniYjmi6bmiKrlmajkuLrlhbHkuqtcblxuXG4gIF9jcmVhdGVDbGFzcyhDb3JlLCBbe1xuICAgIGtleTogXCJ1c2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXNlKG5ld01pZGRsZXdhcmUpIHtcbiAgICAgIHZhciBvcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgICAgY29yZTogZmFsc2VcbiAgICAgIH07XG4gICAgICB0aGlzLm9uaW9uLnVzZShuZXdNaWRkbGV3YXJlLCBvcHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0ZW5kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmluaXRPcHRpb25zID0gbWVyZ2VSZXF1ZXN0T3B0aW9ucyh0aGlzLmluaXRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMubWFwQ2FjaGUuZXh0ZW5kT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9IC8vIOaJp+ihjOivt+axguWJjeaLpuaIquWZqFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhbFJlcXVlc3RJbnRlcmNlcHRvcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVhbFJlcXVlc3RJbnRlcmNlcHRvcnMoY3R4KSB7XG4gICAgICB2YXIgcmVkdWNlciA9IGZ1bmN0aW9uIHJlZHVjZXIocDEsIHAyKSB7XG4gICAgICAgIHJldHVybiBwMS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgICBjdHgucmVxLnVybCA9IHJldC51cmwgfHwgY3R4LnJlcS51cmw7XG4gICAgICAgICAgY3R4LnJlcS5vcHRpb25zID0gcmV0Lm9wdGlvbnMgfHwgY3R4LnJlcS5vcHRpb25zO1xuICAgICAgICAgIHJldHVybiBwMihjdHgucmVxLnVybCwgY3R4LnJlcS5vcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYWxsSW50ZXJjZXB0b3JzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShDb3JlLnJlcXVlc3RJbnRlcmNlcHRvcnMpLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5pbnN0YW5jZVJlcXVlc3RJbnRlcmNlcHRvcnMpKTtcbiAgICAgIHJldHVybiBhbGxJbnRlcmNlcHRvcnMucmVkdWNlKHJlZHVjZXIsIFByb21pc2UucmVzb2x2ZSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIGN0eC5yZXEudXJsID0gcmV0LnVybCB8fCBjdHgucmVxLnVybDtcbiAgICAgICAgY3R4LnJlcS5vcHRpb25zID0gcmV0Lm9wdGlvbnMgfHwgY3R4LnJlcS5vcHRpb25zO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0KHVybCwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIG9uaW9uID0gdGhpcy5vbmlvbjtcbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIHJlcToge1xuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIG9wdGlvbnM6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVzOiBudWxsLFxuICAgICAgICBjYWNoZTogdGhpcy5tYXBDYWNoZSxcbiAgICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvcnM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoQ29yZS5yZXNwb25zZUludGVyY2VwdG9ycyksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluc3RhbmNlUmVzcG9uc2VJbnRlcmNlcHRvcnMpKVxuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndXJsIE1VU1QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX3RoaXMuZGVhbFJlcXVlc3RJbnRlcmNlcHRvcnMob2JqKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gb25pb24uZXhlY3V0ZShvYmopO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKG9iai5yZXMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gb2JqLnJlcS5vcHRpb25zLmVycm9ySGFuZGxlcjtcblxuICAgICAgICAgIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0gZXJyb3JIYW5kbGVyKGVycm9yKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZXF1ZXN0VXNlXCIsXG4gICAgdmFsdWU6IC8vIOivt+axguaLpuaIquWZqCDpu5jorqQgeyBnbG9iYWw6IHRydWUgfSDlhbzlrrnml6fniYjmnKzmi6bmiKrlmahcbiAgICBmdW5jdGlvbiByZXF1ZXN0VXNlKGhhbmRsZXIpIHtcbiAgICAgIHZhciBvcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgICAgZ2xvYmFsOiB0cnVlXG4gICAgICB9O1xuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnRlcmNlcHRvciBtdXN0IGJlIGZ1bmN0aW9uIScpO1xuXG4gICAgICBpZiAob3B0Lmdsb2JhbCkge1xuICAgICAgICBDb3JlLnJlcXVlc3RJbnRlcmNlcHRvcnMucHVzaChoYW5kbGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VSZXF1ZXN0SW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSAvLyDlk43lupTmi6bmiKrlmagg6buY6K6kIHsgZ2xvYmFsOiB0cnVlIH0g5YW85a655pen54mI5pys5oum5oiq5ZmoXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNwb25zZVVzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNwb25zZVVzZShoYW5kbGVyKSB7XG4gICAgICB2YXIgb3B0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICAgIGdsb2JhbDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignSW50ZXJjZXB0b3IgbXVzdCBiZSBmdW5jdGlvbiEnKTtcblxuICAgICAgaWYgKG9wdC5nbG9iYWwpIHtcbiAgICAgICAgQ29yZS5yZXNwb25zZUludGVyY2VwdG9ycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZVJlc3BvbnNlSW50ZXJjZXB0b3JzLnB1c2goaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvcmU7XG59KCk7XG5cbkNvcmUucmVxdWVzdEludGVyY2VwdG9ycyA9IFthZGRmaXhdO1xuQ29yZS5yZXNwb25zZUludGVyY2VwdG9ycyA9IFtdO1xuXG4vKipcbiAqIOW9k+aJp+ihjCDigJzlj5bmtojor7fmsYLigJ0g5pON5L2c5pe25Lya5oqb5Ye6IENhbmNlbCDlr7nosaHkvZzkuLrkuIDlnLpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubWVzc2FnZSA/IFwiQ2FuY2VsOiBcIi5jb25jYXQodGhpcy5tZXNzYWdlKSA6ICdDYW5jZWwnO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxuLyoqXG4gKiDpgJrov4cgQ2FuY2VsVG9rZW4g5p2l5Y+W5raI6K+35rGC5pON5L2cXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIOWPlua2iOaTjeS9nOW3suiiq+iwg+eUqOi/h1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG4vKipcbiAqIOWmguaenOivt+axguW3sue7j+WPlua2iO+8jOaKm+WHuiBDYW5jZWwg5byC5bi4XG4gKi9cblxuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuLyoqXG4gKiDpgJrov4cgc291cmNlIOadpei/lOWbniBDYW5jZWxUb2tlbiDlrp7kvovlkozlj5bmtoggQ2FuY2VsVG9rZW4g55qE5Ye95pWwXG4gKi9cblxuXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5mdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59XG5cbnZhciByZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgdmFyIGluaXRPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGNvcmVJbnN0YW5jZSA9IG5ldyBDb3JlKGluaXRPcHRpb25zKTtcblxuICB2YXIgdW1pSW5zdGFuY2UgPSBmdW5jdGlvbiB1bWlJbnN0YW5jZSh1cmwpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIG1lcmdlT3B0aW9ucyA9IG1lcmdlUmVxdWVzdE9wdGlvbnMoY29yZUluc3RhbmNlLmluaXRPcHRpb25zLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29yZUluc3RhbmNlLnJlcXVlc3QodXJsLCBtZXJnZU9wdGlvbnMpO1xuICB9OyAvLyDkuK3pl7Tku7ZcblxuXG4gIHVtaUluc3RhbmNlLnVzZSA9IGNvcmVJbnN0YW5jZS51c2UuYmluZChjb3JlSW5zdGFuY2UpO1xuICB1bWlJbnN0YW5jZS5mZXRjaEluZGV4ID0gY29yZUluc3RhbmNlLmZldGNoSW5kZXg7IC8vIOaLpuaIquWZqFxuXG4gIHVtaUluc3RhbmNlLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiB7XG4gICAgICB1c2U6IENvcmUucmVxdWVzdFVzZS5iaW5kKGNvcmVJbnN0YW5jZSlcbiAgICB9LFxuICAgIHJlc3BvbnNlOiB7XG4gICAgICB1c2U6IENvcmUucmVzcG9uc2VVc2UuYmluZChjb3JlSW5zdGFuY2UpXG4gICAgfVxuICB9OyAvLyDor7fmsYLor63ms5Xns5bvvJogcmVndWVzdC5nZXQgcmVxdWVzdC5wb3N0IOKApuKAplxuXG4gIHZhciBNRVRIT0RTID0gWydnZXQnLCAncG9zdCcsICdkZWxldGUnLCAncHV0JywgJ3BhdGNoJywgJ2hlYWQnLCAnb3B0aW9ucycsICdycGMnXTtcbiAgTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB1bWlJbnN0YW5jZVttZXRob2RdID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHVtaUluc3RhbmNlKHVybCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICAgfSkpO1xuICAgIH07XG4gIH0pO1xuICB1bWlJbnN0YW5jZS5DYW5jZWwgPSBDYW5jZWw7XG4gIHVtaUluc3RhbmNlLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG4gIHVtaUluc3RhbmNlLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG4gIHVtaUluc3RhbmNlLmV4dGVuZE9wdGlvbnMgPSBjb3JlSW5zdGFuY2UuZXh0ZW5kT3B0aW9ucy5iaW5kKGNvcmVJbnN0YW5jZSk7IC8vIOaatOmcsuWQhOS4quWunuS+i+eahOS4remXtOS7tu+8jOS+m+W8gOWPkeiAheiHqueUsee7hOWQiFxuXG4gIHVtaUluc3RhbmNlLm1pZGRsZXdhcmVzID0ge1xuICAgIGluc3RhbmNlOiBjb3JlSW5zdGFuY2Uub25pb24ubWlkZGxld2FyZXMsXG4gICAgZGVmYXVsdEluc3RhbmNlOiBjb3JlSW5zdGFuY2Uub25pb24uZGVmYXVsdE1pZGRsZXdhcmVzLFxuICAgIGdsb2JhbDogT25pb24uZ2xvYmFsTWlkZGxld2FyZXMsXG4gICAgY29yZTogT25pb24uY29yZU1pZGRsZXdhcmVzXG4gIH07XG4gIHJldHVybiB1bWlJbnN0YW5jZTtcbn07XG4vKipcbiAqIGV4dGVuZCDmlrnms5Xlj4LogIPkuoZreSwg6K6p55So5oi35Y+v5Lul5a6a5Yi26YWN572uLlxuICogaW5pdE9waW9ucyDliJ3lp4vljJblj4LmlbBcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhDYWNoZSDmnIDlpKfnvJPlrZjmlbBcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdXJs5YmN57yAXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvckhhbmRsZXIg57uf5LiA6ZSZ6K+v5aSE55CG5pa55rOVXG4gKiBAcGFyYW0ge29iamVjdH0gaGVhZGVycyDnu5/kuIDnmoRoZWFkZXJzXG4gKi9cblxuXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGluaXRPcHRpb25zKSB7XG4gIHJldHVybiByZXF1ZXN0KGluaXRPcHRpb25zKTtcbn07XG4vKipcbiAqIOaatOmcsiBmZXRjaCDkuK3pl7Tku7bvvIzkv53pmpzkvp3ml6flj6/ku6Xkvb/nlKhcbiAqL1xuXG52YXIgZmV0Y2gkMSA9IHJlcXVlc3Qoe1xuICBwYXJzZVJlc3BvbnNlOiBmYWxzZVxufSk7XG52YXIgcmVxdWVzdCQxID0gcmVxdWVzdCh7fSk7XG5cbmV4cG9ydHMuT25pb24gPSBPbmlvbjtcbmV4cG9ydHMuUmVxdWVzdEVycm9yID0gUmVxdWVzdEVycm9yO1xuZXhwb3J0cy5SZXNwb25zZUVycm9yID0gUmVzcG9uc2VFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlcXVlc3QkMTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuZXhwb3J0cy5mZXRjaCA9IGZldGNoJDE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/umi-request/dist/index.js\n");

/***/ })

};
;